//T901562 JOB ,'===> SOS-D <===',TIME=(,15)
/*JOBPARM LINES=9000
//*
//SVC13ASM EXEC PROC=ASMHC,CPARM='RENT'
//ASM.SYSLIN DD DSN=&&O(D),VOL=SER=ACA105,SPACE=(2960,(20,10,1)),      X
//             DCB=(LRECL=80,RECFM=FB)
//SYSIN  DD *
         TITLE 'SVC 13 ABEND MODULE'
*
* DSECT FOR REFERENCING CONTROL BLOCK ITEMS.
*
CVT      DSECT
CVTTCBP  DS    A (IEATCBP)  POINTER TO 'TCB WORDS'
CVTSVCTA DS    A (SVCTABLE) POINTER TO THE SVCTABLE
CVTHEAD  DS    A (0) ADDRESS OF FIRST TCB IN TCB CHAIN
CVTUCBS  DS    A (0) ADDRESS OF FIRST UCB IN UCB CHAIN
CVTRQEHD DS    A (RQEHEADR)  ADDRESS OF THE RQE-HEADER
CVTMODEF DS    A (MODEFLAG)  FOR V6.4 AND FUTURE
CVTC100H DS    A (CB100HDR) ADDRESS OF THE RB-HEADER
CVT0DS   DS    A (DISPATCH) ADDRESS OF THE DISPATCHER
CVTBGNIO DS    A (BEGINIO) ADD. OF THE BEGIN I/O ROUTINE IN IOSUP.
CVTCHAP  DS    A (CHAP)   ADD. OF THE CHAP ROUTINE
CVTSUB1  DS    A (SUB1) ADDRESS OF SUBROUTINE 1 IN 'LPA'
CVTSUB2  DS    A (SUB2) ADDRESS OF SUBROUTINE 2 IN 'LPA'
CVTBRABN DS    A (BRABEND) ADD. BRANCH-ABEND ROUTINE   V6.5
CVTTYP1F DS    A (TYP1FLAG)
CVTRQENQ DS    A (RQEENQ)  ADD. OF ROUT. TO ENQ RQE-S ON UCB-S
CVTPARHD DS    A (0) A OF PARTITION-S 'HEADER'               V6.9
CVTMSECB DS    A (0) A OF MASTER SCHEDULER ECB               V6.9
CVTMSINI DS    A (0) A OF MSTR. SCH. INITILIZATION ROUT.     V6.9
CVTMSWLO DS    A (0) A OF MSTR. SCH. WAIT LOOP (SVC 1)       V6.9
CVTMSDAT DS    A (0) A OF MSTR. SCH. DATA AREA               V6.9
CVTEXIT  SVC   3
CVTBRET  BCR   15,14
CVTSFR14 DS    A (0) ADDR. OF R14 AFTER BALR R14,R6 IN SVCFLIH V6.83
CVTMZ00  DS    A (0) ADD. OF HIGHEST 'MACHINE' BYTE. RPR-9/22/87
CVTIDENT DS    CL4'CVT ' DOCUMENTATION
CVTLNTH  EQU   *-CVT     LENGTH OF THE CVT  (X'60')
*
TCB      DSECT
TCBRB    DS    A(0)     ADD OF RB (OR ZERO IF NONE)
TCBPIE   DS    A (0) ADD. OF PIE (MVT) OR SCA (MVS) RPR-9/22/87
TCBTNAME DS    CL8'TCB NAME' ('DEB' & 'TIOT' HERE IN REAL)  V6.83
TCBPNAME DS    CL8'PGM NAME' NAME OF PROGRAM BEING EXECUTED  V6.9
TCBNAME  EQU   TCBTNAME  EQUATE PRIOR TO REMOVING 'TCBNAME'  V6.83
TCBTSSIO DS    A(0)  TIME (FROM X'50') SIO LAST STARTED FOR THIS TCB
TCBPFK   DS    X'CF'     C = KEY OF THIS TCB, F = B'1111'B
TCBFLGS  DS    5X'00' FLGS 4+5: X'0000', DISPATCH.: X'FFFF' NOT-SO
TCBLMP   DS    X'00' LIMIT PRIORITY OF THIS TCB
TCBDSP   DS    X'00' DISPATCHING PRIORITY OF THIS TCB.
TCBTWAIT DS    A(0)  SUMMATION OF WAIT TIME ACCUMULATED -- THIS TCB
         DS    A(0) RESERVED                                 V6.9
TCBIDENT DS    CL4'TCB ' DOCUMENTATION
TCBGRS   DS    16F'-5' SAVE AREA FOR REGS.
         DS    A(0) RESERVED                                 V6.9
TCBTCB   DS    A(0)   ADD OF NEXT TCB IN CHAIN (OR ZERO IF END)
TCBDMSCA DS    A(0) LOCATION USED FOR DUMMY SCA              V6.9
         DS    A(0) RESERVED                                 V6.9
TCBAPIE  DS    A(0) ADDR. OF PIE AREA IN TASKS REGION        V6.9
TCBAPARM DS    A(0) ADDR. OF 'PARM' AREA IN TASKS REGION     V6.9
TCBFSA   DS    A(0)  ADD OF FIRST SAVE AREA (18F) FOR USE OF PROG.
TCBAWORK DS    A(0)  ADD OF WORK AREA IN THIS TCB-S 'REGION'
TCBRSTAR DS    A(0)  ADDRESS OF START OF REGION USED BY THIS TCB
TCBRSIZE DS    A(0)  SIZE (BYTES) OF REGION USED BY THIS TCB
TCBDPQE  DS    A(0) POINTER TO THE DUMMY PQE                 V6.83
TCBMSS   DS    A(0) POINTER TO THE QUEUE OF SPQE-S           V6.83
TCBTDISP DS    A(0)  TIME (FROM X'50') THIS TCB LAST DISPAT.  V6.9
TCBTWALS DS    A(0) START TIMER VALUE 'WALL CLOCK'            V6.9
TCBTWASL EQU   TCBTWALS EQUATE TO HANDLE RPR TYPEO (TEMPOR.)  V6.9
TCBTWALA DS    A(0) ACCUMULATED 'WALL CLOCK' TIME             V6.9
TCBTCPUP DS    A(0) ACCUM. 'TASK' CPU TIME (PROBLEM STATE)    V6.9
TCBTCPU  EQU   TCBTCPUP  OLD 'TCBTCPU' WILL BE REMOVED IN FUT.V6.9
TCBTCPUS DS    A(0) ACCUM. 'TASK' CPU TIME (SUPERVISOR ST.)   V6.9
TCBTSYS  DS    A(0) ACCUM. 'SYSTEM' CPU TIME                  V6.9
TCBTATQE DS    A(0) ADDRESS OF TIMER QUEUE ELEMENT            V6.9
TCBTSLIC DS    A(0) ADDRESS OF TIME SLICE PARAMETERS          V6.9
         DS    7A(0) RESERVED                                V6.9
TCBBACK  DS    A(0) BACKWARD (REV. OF TCBTCB) TCB CHA. POINT. V6.9
TCBFRS   DS    4D   STORAGE FOR FOUR FLOATING POINT REGS.    V6.83
TCBLNTH  EQU   *-TCB     LENGTH OF THE TCB  (X'100')         V6.83
*
RB       DSECT
RBTYPE   DS    CL4'SVRB' DOCUMENTATION: SVRB OR PRB OR OTHER
RBTCB    DS    A         ADD. OF THE TCB FOR THIS TASK
RBFLGS03 DS    4X        3X RESERVED
RBFLGS3  EQU   RBFLGS03+3   1... .... BIT=1 INDICATES RBLINK IS TCB
RBCDE    DS    A         RESERVED
RBOPSW   DS    XL8       RESUME PSW FOR THIS TASK
RBPGNQ   DS    A         RESERVED
RBLINK   DS    A(0) POINTER TO PREV. RB ON THE CHAIN (LAST 3 BYTES)
*                        OR TCB WHEN THIS IS LAST RB ON THE CHAIN.
*                        (RBFLGS3 -- BIT 0, SET TO 1 INDICATES TCB)
RBWCF    EQU   RBLINK    X'00'  COUNT OF EVENTS WAITED FOR
RBGRSAVE DS    16F       REGISTERS 0-15 WHEN REQUEST ENTERED
RBFRSAVE DS    4D        SAVE AREA FOR FLOATING PT. REGISTERS
RBLNTH   EQU   *-RB      LENGTH OF A REQUEST BLOCK  (X'80')
*
UCB      DSECT
UCBIDENT DS    CL3'UCB',X'FF' DOCUMENTATION
UCBCHAN  DS    X'0000' DEVICE ADDRESS IN HEX
UCBFLA   DS    X'00' = FREE, X'FF' = BUSY
UCBFLB   DS    X'00'   RESERVED
UCBUCB   DS    A(0)    ADD. NEXT UCB ON CHAIN OR 0 IF THIS = LAST.
UCBNAME  DS    CL4'NAME' DEVICE ADDRESS IN EBCDIC
UCBCURQE DS    A(0)     ADDRESS OF RQE CURRENTLY BEING PROCESSED
UCBWARQE DS    A(0) ADD. FIRST RQE IN WAIT QUEUE, / 0 IF NONE THERE
UCBIOSTR DS    A(0)   ADDRESS OF DEVICE'S I/O START ROUTINE
         DS    A(0)   RESERVED
UCBLNTH  EQU   *-UCBIDENT LENGTH OF UCB  (X'20')
*
*
* THIS DSECT IS USED TO REFERENCE THE 256 BYTE WORK AREA THAT IS SET
* ASIDE IN EACH USER REGION FOR SVC 13.
*
SVC13WRK DSECT
ABNDOUT  DS    CL133              ABEND MESSAGE OUTPUT LINE
ABNDCODE DS    F                  REG 1 ON ENTRY TO SVC 13
ABWORK1  DS    D,CL1              WORK FIELD FOR MAKING HEX VALUES
ABWORK2  DS    F,CL1              PRINTABLE
ABWORK3  DS    F                  WORK FIELD
*
* THIS I/O BLOCK IS USED FOR ISSUING MESSAGES VIA SVC 0
*
ABENDIOB DS    0F
         DS    CL4                I/O BLOCK IDENTIFIER
         DS    XL2                XREAD/XPRNT CODE (NON-CHANNEL)
         DS    XL2                MESSAGE PRINT REQUEST
ABMSGADD DS    A(0)               ADDRESS OF MESSAGE TO BE PRINTED
         DS    H                  LENGTH OF EACH MESSAGE IS 133 BYTES
*
******
*
* THIS MACRO SIMPLY EMULATES THE ASSIST/V XOPC INSTRUCTION. THE
* OPERAND ===> MUST <=== BE GIVEN IN DECIMAL.
*
******
         MACRO
&NAME    XOPC &OPERAND
&NAME    DC    X'01',AL1(&OPERAND.)
         MEND
         EJECT
*
*   >        A   BBBB  EEEEE N   N DDDD     SSSSS V   V CCCCC     <
*    >      A A  B   B E     NN  N D   D    S     V   V C        <
*     >    A   A BBBB  EEE   N N N D   D    SSSSS V   V C       <
*    >     AAAAA B   B E     N  NN D   D        S  V V  C        <
*   >      A   A BBBB  EEEEE N   N DDDD     SSSSS   V   CCCCC     <
*
*
* THE FOLLOWING CODE COMPRISES THE SVC 13 ABEND MODULE, WHICH GETS
* CONTROL EITHER UPON ABNORMAL TERMINATION OF A PROGRAM OR WHEN IT
* REQUESTED EXPLICITY BY A USER PROGRAM OR SYSTEM TASK. THIS MODULE
* WILL PRINT THE FOLLOWING ITEMS:
*
*    1) THE PSW AT THE TIME OF THE ABEND
*    2) THE INTERRUPT CODE (BOTH THE SYSTEM CODE AND THE USER CODE) &
*       THE COMPLETE CONTENTS OF REG 1
*    3) THE GENERAL PURPOSE REGISTER VALUES AT THE TIME OF THE ABEND
*    4) THE FLOATING POINTER REGISTER VALUES AT THE TIME OF ABEND
*    5) THE STORAGE AT PSW +/- 6 BYTES, TO AID IN DEBUGGING.
*
* UPON ENTRY TO THIS ROUTINE, THE REGISTERS ARE TO CONTAIN THE
* THE FOLLOWING VALUES:
*
*   REG 1 = INTERRUPT CODE IN THE FORM XXSSSUUU, WHERE SSS IS THE
*           SYSTEM COMPLETION CODE AND UUU IS THE USER COMPLETION CODE.
*           THE HIGH ORDER BIT IS SET IF A DUMP IS DESIRED
*   REG 3 = ADDRESS OF THE CVT
*   REG 4 = ADDRESS OF THE CURRENT TCB
*   REG 5 = ADDRESS OF THE CURRENT RB
*   REG 14 = RETURN ADDRESS FROM THIS MODULE
*
* THE COMPLETE REGISTER USAGE OF THIS ROUTINE IS AS FOLLOWS:
*
*   REG 1 = USAGE NOT DEFINED
*   REG 2 = USAGE NOT DEFINED
*   REG 3 = ADDRESS OF THE CVT
*   REG 4 = ADDRESS OF THE CURRENT TCB
*   REG 5 = ADDRESS OF THE CURRENT RB
*   REG 6 = BASE REGISTER FOR SVC 13 ROUTINE
*   REG 7 = USAGE NOT DEFINED
*   REG 8 = USAGE NOT DEFINED
*   REG 9 = USAGE NOT DEFINED
*   REG 10 = WORK REGISTER 1
*   REG 11 = WORK REGISTER 2
*   REG 12 = USAGE NOT DEFINED
*   REG 13 = USAGE NOT DEFINED
*   REG 14 = RETURN ADDRESS TO SVC FLIH
*   REG 15 = USAGE NOT DEFINED
*
MYSVC13  START X'7500'
*
* ESTABLISH ADDRESSABILITY INTO THIS MODULE.
*
         USING MYSVC13,R6         ESTABLISH ADDRESSABILITY
*
* WE MUST SET UP ADDRESSABILITY INTO OUR CONTROL BLOCK DSECTS. WE MUST
* ADDRESS THE CVT, TCB, RB, AND THE 256 BYTE WORK AREA WHICH IS LOCATED
* WITHIN THE 4K USER REGION.
*
         USING CVT,R3             ESTABLISH ADDRESSIBILITY INTO CVT
         USING TCB,R4             ESTABLISH ADDRESSIBILITY INTO TCB
         USING RB,R5              ESTABLISH ADDRESSIBILITY INTO RB
*
         L     R2,TCBAWORK        SET UP ADDRESSABILITY INTO WORK FLD
         USING SVC13WRK,R2
*
* NOW WE MUST INITIALIZE THE FIELDS IN THE USER REGION POINTED TO BY
* THE CURRENT TCB. THIS INCLUDES THE IOB STORED IN THE USER REGION.
*
         ST    R1,ABNDCODE        STORE ABEND CODE FOR LATER USE
*
         MVC   ABENDIOB(14),IOBMASK MOVE INITIAL VALUES INTO THE IOB
         LA    R8,ABNDOUT         GET @ OF MSG LINE IN 4K USER REGION
         ST    R8,ABMSGADD        STORE @ OF MSG LINE IN IOB
*
* SINCE MULTIPLE PROGRAMS MAY ABEND AT ONCE, AND THEIR OUTPUT LINES
* MAY GET CONFUSED, WE WILL PRINT THE TASK NAME AT THE BEGINNING OF
* EVERY LINE. TO DO THIS, WE MUST PHYSICALLY MOVE IT.
*
         MVI   ABNDOUT,C' '       CLEAR OUT THE PRINT LINE
         MVC   ABNDOUT+1(132),ABNDOUT
*
         MVC   ABNDOUT(25),ABNDMSG1
         MVC   ABNDOUT+2(8),TCBPNAME
*
* HERE WE WILL PREPARE THE SYSTEM ABEND CODE AND THE USER ABEND CODE
* TO BE PRINTED. THESE ITEMS WILL ACTUALLY BE PRINTED ON THE SAME LINE
* OF OUTPUT AS THE PSW AT TIME OF ABEND.
*
         BAL   R12,PRNTSVC0                PRINT A BLANK LINE
         MVC   ABNDOUT+22(90),ABNDMSG2     MOVE PSW MSG CONSTANT
*
         LA    R8,ABTRAN          GET ADDRESS OF TRANSLATE TABLE
         LA    R0,240             ADJUST FOR ABBREVIATED TABLE
         SR    R8,R0
*
         MVC   ABWORK1(4),ABNDCODE STORE COMPL CODE PASSED TO SVC 13
         UNPK  ABWORK2(9),ABWORK1(5) TRANSLATE SYSTEM CODE INTO
         TR    ABWORK2(8),0(R8)      PRINTABLE FORM
         MVC   ABNDOUT+88(3),ABWORK2+2 MOVE RESULT TO A MSG AREA
*
* SINCE THE USER COMPLETION CODE IS TO BE PRINTED IN DECIMAL, WE
* MUST ADD SOME CODE TO ISOLATE AND CONVERT THAT VALUE BEFORE
* SENDING IT THE A MESSAGE AREA TO BE PRINTED.
*
         L     R1,ABNDCODE        GET REG 1 ON ENTRY
         LA    R0,4095            SET UP MASK TO ISOLATE RIGHT 3 HITS
         NR    R1,R0              CLEAR OUT ALL BUT THOSE 12 BITS
*
         CVD   R1,ABWORK1         CONVERT THE VALUE TO PACKED FORMAT
         UNPK  ABWORK2(5),ABWORK1+5(3) UNPACK THE VALUE AND ENSURE
         OI    ABWORK2+4,X'F0'         THE RIGHTMOST DIGIT PRINTABLE
         MVC   ABNDOUT+93(4),ABWORK2+1 MOVE RESULT TO MSG AREA
*
* HERE WE WILL PRINT THE PSW AT THE TIME OF ABEND. THE PSW TO BE
* DISPLAYED IS FOUND IN THE SECOND RB IN THE CHAIN, JUST BELOW THE
* SVRB REQUEST FOR THIS MODULE.
*
         L     R5,RBLINK          POINT TO RB WITH ABENDING PSW
*
         LA    R1,4               SVC 0 THE LINE AUTOMATICALLY
         LA    R7,RBOPSW          GET ADDRESS OF THE RB OLD PSW
         LA    R8,4               PRINT FOUR BYTES AT A TIME
         LA    R9,ABNDOUT+49      PRINT LINE POSITION
         LA    R10,2              PRINT 2 GROUPS OF 4 BYTES EACH
         LA    R11,1              ONE SPACE IN BETWEEN EACH GROUP
         BAL   R12,PRNTMEM        PRINT THE PSW IN THE RB
*
* FOR SOS-D, WE WILL PRINT OUT THE ENTIRE CONTENTS OF R1 IN HEX.
*
         MVC   ABNDOUT+22(110),ABNDOUT+21  CLEAR OUT THE MSG LINE
         MVC   ABNDOUT+69(25),ABNDMSG7     MOVE PSW MSG CONSTANT
*
         LA    R1,4               SVC 0 THE LINE AUTOMATICALLY
         LA    R7,ABNDCODE        PRINT THE VALUE IN REG 1
         LA    R8,4               PRINT FOUR BYTES AT A TIME
         LA    R9,ABNDOUT+94      PRINT LINE POSITION
         LA    R10,1              PRINT ONLY 1 GORUP OF 4 BYTES
         BAL   R12,PRNTMEM        PRINT THE PSW IN THE RB
*
* HERE WE WILL PREPARE THE CONTENTS OF THE GENERAL PURPOSE REGISTERS,
* WHICH ARE STORED IN THE SVRB REGISTER SAVE AREA, TO BE PRINTED. THE
* VALUES ARE NOT ACTUALLY PRINTED UNTIL A LITTLE BIT LATER IN THIS
* MODULE; THIS LOOP SIMPLY SETS UP THE VALUES IN THE MESSAGE AREA.
*
         L     R5,TCBRB           OBTAIN @ OF FIRST RB IN CHAIN
*
         MVC   ABNDOUT+23(110),ABNDOUT+22  CLEAR OUT THE MSG LINE
         BAL   R12,PRNTSVC0                PRINT A BLANK LINE
         MVC   ABNDOUT+26(10),ABNDMSG3     MOVE REG MSG CONSTANT
*
         LA    R7,RBGRSAVE        GET ADDRESS OF THE RB REGS VALUES
         LA    R13,2              WE WILL PRINT TWO LINES OF OUTPUT
PRNTGPRS DS    0H
         LA    R1,4               SVC 0 THE LINE AUTOMATICALLY
         LA    R8,4               PRINT FOUR BYTES AT A TIME
         LA    R9,ABNDOUT+40      SET LOCATION OF VALUES ON PRINT LINE
         LA    R10,8              PRINT 8 REG VALUES ON EACH LINE
         LA    R11,3              SPACING IN BETWEEN EACH GROUP
         BAL   R12,PRNTMEM        PRINT THE PSW IN THE RB
*
         MVC   ABNDOUT+26(10),ABNDMSG4     MOVE REG MSG CONSTANT
         BCT   R13,PRNTGPRS
*
* HERE WE WILL PREPARE THE CONTENTS OF THE FLOATING POINT REGISTERS,
* WHICH ARE STORED IN THE SVRB REGISTER SAVE AREA, TO BE PRINTED. THE
* VALUES ARE NOT ACTUALLY PRINTED UNTIL A LITTLE BIT LATER IN THIS
* MODULE; THIS LOOP SIMPLY SETS UP THE VALUES IN THE MESSAGE AREA.
*
         MVC   ABNDOUT+23(110),ABNDOUT+22  CLEAR OUT THE MSG LINE
         BAL   R12,PRNTSVC0                PRINT A BLANK LINE
         MVC   ABNDOUT+26(10),ABNDMSG5     MOVE REG MSG CONSTANT
*
         LA    R1,8               PRINTING WILL BE DONE MANUALLY
         LA    R7,RBFRSAVE        GET ADDRESS OF THE RB REGS VALUES
         LA    R8,4               PRINT FOUR BYTES AT A TIME
         LA    R9,ABNDOUT+40      SET LOCATION OF VALUES ON PRINT LINE
         LA    R13,4
PRNTFLTR DS    0H
         LA    R10,1              PRINT 4 REG VALUES ON EACH LINE
         LA    R11,0              SPACING IN BETWEEN EACH GROUP
         BAL   R12,PRNTMEM        PRINT THE PSW IN THE RB
*
         LA    R10,1              PRINT 4 REG VALUES ON EACH LINE
         LA    R11,6              SPACING IN BETWEEN EACH GROUP
         BAL   R12,PRNTMEM        PRINT THE PSW IN THE RB
*
         BCT   R13,PRNTFLTR
         BAL   R12,PRNTSVC0
*
*
* HERE WE WILL PRINT OUT THE 12 BYTES AT THE STORAGE LOCATIONS FROM
* PSW - 6 TO PSW + 6. THIS IS OFTEN ENOUGH INFORMATION TO DETERMINE
* THE CAUSE OF AN ABEND. IF THIS RANGE OF ADDRESSES OVERLAPS AN
* INVALID STORAGE LOCATION, A "**" WILL BE PRINTED FOR EACH NONEXISTANT
* BYTE.
*
         MVC   ABNDOUT+23(110),ABNDOUT+22  CLEAR OUT THE MSG LINE
         BAL   R12,PRNTSVC0                PRINT A BLANK LINE
         MVC   ABNDOUT+26(40),ABNDMSG6     MOVE REG MSG CONSTANT
*
         L     R5,RBLINK          OBTAIN PSW @ FROM 2ND RB IN CHAIN
*
         LA    R7,12              TOTAL # OF BYTES TO BE PRINTED
         LA    R10,6              NUMBER OF BYTES ON EACH SIDE OF PSW
*
         ICM   R9,7,RBOPSW+5      LOCATION OF 1ST BYTE TO BE PRINTED
         SR    R9,R10             START AT PSW - 6 BYTES
         LA    R9,0(,R9)          CLEAR HIGH BYTE OF REG 9
*
         LA    R8,ABNDOUT+58      MESSAGE AREA WHERE OUTPUT IS GOING
         L     R11,CVTMZ00        GET HIGHEST EXISTING MACHINE BYTE @
         LA    R0,1               STORAGE LOCATION INCREMENT VALUE
*
PRNTBYTE DS    0H
         LTR   R7,R7              HAVE WE PRINTED ALL 12 BYTES?
         BZ    PRNTGRP            IF SO, EXIT THE LOOP
*
         CR    R9,R11             IS THIS A VALID MEMORY LOCATION?
         BNH   PRNTIT             IF SO, PRINT THE BYTE
         MVI   0(R8),C'*'         OTHERWISE FILL SPACE IN WITH '*'S
         MVI   1(R8),C'*'
         B     NEXTBYTE           AND CONTINUE TO THE NEXT BYTE
*
PRNTIT   DS    0H
*
         LA    R15,ABTRAN         GET ADDRESS OF TRANSLATE TABLE
         LA    R0,240             ADJUST FOR ABBREVIATED TABLE
         SR    R15,R0
*
         MVC   ABWORK1(1),0(R9)   MOVE VALUE OF BYTE TO WORK AREA
         UNPK  ABWORK2(3),ABWORK1(2) CONVERT TO PRINTABLE HEX FORMAT
         TR    ABWORK2(2),0(R15)
         MVC   0(2,R8),ABWORK2    MOVE RESULT TO MESSAGE AREA
*
NEXTBYTE DS    0H
         LA    R9,1(,R9)          POINT TO NEXT BYTE IN STORAGE
         LR    R15,R7             DETERMINE SPACING VALUE (WE WILL
         N     R15,SPCMASK        PRINT BYTES IN GROUPS OF TWO)
         LA    R8,2(R15,R8)       POINT TO NEXT POSITION IN PRINT LINE
*
         BCTR  R7,R0              DECREMENT NUMBER OF REGS LEFT
         CR    R7,R10             HAVE WE PRINTED 1ST 6 BYTES YET?
         BNE   PRNTBYTE           IF NOT, KEEP GOING
         LA    R8,2(,R8)          OTHERWISE, INSERT SOME SPACES
         B     PRNTBYTE
*
PRNTGRP  DS    0H
         BAL   R12,PRNTSVC0       PRINT OUT THE LINE
         MVC   ABNDOUT+23(110),ABNDOUT+22  CLEAR OUT THE MSG LINE
         BAL   R12,PRNTSVC0                PRINT A BLANK LINE
*
* WE MUST RUN THE REQUEST BLOCK CHAIN AND POINT THE ADDRESS PORTION
* OF EACH PSW TO THE SVC 3 MODULE. THIS WILL REMOVE EACH RB FROM THE
* CHAIN EACH TIME A DISPATCH IS ATTEMPTED.
*
         L     R5,TCBRB           LOAD @ OF FIRST RB IN CHAIN
*
SETRBPSW DS    0H
         STCM  R14,7,RBOPSW+5     SET RESUME ADDRESS TO SVC 3 MODULE
         CLM   R4,7,RBLINK+1      ARE THERE MORE RBS ON THE CHAIN?
         BE    EXITABND           IF NOT, EXIT THIS LOOP
         L     R5,RBLINK          OTHERWISE, POINT TO NEXT RB
         B     SETRBPSW           AND CHANGE THE RB'S RESUME PSW
*
* NOW WE WILL EXIT THE SVC 13 RTN.
*
EXITABND DS    0H
         BR    R14                BRANCH TO CVT EXIT
*
* THIS SMALL SUBROUTINE WILL PRINT BYTES OF CONSECUTIVE MEMORY
* LOCATIONS STARTING AT THE LOCATION GIVEN FOR THE GIVEN NUMBER OF
* ITERATIONS, AND SPACE THEM OUT BY THE AMOUNT GIVEN.
*
* THE FOLLOWING REGISTER VALUES ARE ASSUMED BY THE PROCEDURE:
*
*     REG 7 = STARTING ADDRESS OF BYTES TO PRINT (DOES NOT HAVE TO
*             BE ON A FULLWORD BOUNDARY.
*     REG 8 = SIZE OF EACH GROUP TO PRINT (FROM 1 TO 8 BYTES)
*     REG 9 = PRINT LINE TARGET ADDRESS
*     REG 10 = TOTAL NUMBER OF GROUPS TO BE PRINTED
*     REG 11 = NUMBER OF SPACES TO PUT IN BETWEEN EACH
*     REG 12 = RETURN ADDRESS TO CALLING ROUTINE
*
* FOR GROUPS LARGER THAN FOUR BYTES, THE PRINT ROUTINE MUST BE CALLED
* SEPERATELY.
*
PRNTMEM  DS    0H
         LA    R15,0(R8,R8)       SIZE OF FIELD IN DIGITS
*
*        LA    R13,ABTRAN         GET ADDRESS OF TRANSLATE TABLE
*        LA    R0,240             ADJUST FOR ABBREVIATED TABLE
*        SR    R13,R0
*
PRNTONE  DS    0H
         EX    R8,MOVEWORK        GET A VALUE FROM STORAGE TO PRINT
         UNPK  ABWORK2(9),ABWORK1(5) CONVERT TO PRINTABLE HEX FORMAT
         OI    ABWORK2+15,X'F0'
*        TR    ABWORK2(8),0(R13)
         TR    ABWORK2(8),ABTRAN-240
         EX    R15,MOVEVALS
*
         AR    R9,R15             GET @ ADDR OF NEXT PRINT LINE AREA
         MVI   0(R9),C' '         MOVE SPACE PAST THE LAST DIGIT
         AR    R9,R11             ADJUST FOR SPACING
         AR    R7,R8              POINT TO THE NEXT VALUE TO PRINT
         BCT   R10,PRNTONE        DO UNTIL ALL BYTES HAVE BEEN PRINTED
         C     R1,MAXBLOCK        IS GROUP SIZE LARGER THAN 8 BYTES?
         BHR   R12                IF SO THEN PRNT MUST BE DONE MANUALLY
*
* PRINT A MESSAGE FROM THE MESSAGE BUFFER.
*
PRNTSVC0 DS    0H
         LA    R1,ABENDIOB        POINT TO MESSAGE I/O BLOCK FOR SVC 0
         XOPC  4                  TURN OFF THE TRACE FOR SVC 0
         SVC   0                  ISSUE SVC TO PERFORM THE I/O
         XOPC  2                  TURN TRACE BACK ON
         LTR   R15,R15            WAS THE PRINT SUCCESSFUL?
         BZR   R12                IF SO THEN GO BACK TO MAIN PROGRAM
*
         XOPC  25                 OTHERWISE, THE IOB WAS INVALID
         DC    C'INVALID I/O BLOCK IN SVC 13' AND WE SHOULD STOP
*
ABNDMSG1 DC    CL25'0''        '' -- ABEND: '
ABNDMSG2 DC    CL90'*** PSW AT ENTRY TO ABEND                      INTEX
               RRUPTION CODE S    U   '
ABNDMSG3 DC    CL10'REGS 0-7'
ABNDMSG4 DC    CL10'REGS 8-15'
ABNDMSG5 DC    CL10'FLTR 0-6'
ABNDMSG6 DC    CL40'STORAGE AT PSW +/- 6 BYTES:'
ABNDMSG7 DC    CL25'REG 1 ON ENTRY TO SVC 13'
*
SVC3ADDR DS    A                  RETURN ADDRESS TO PCHK FLIH
*
SPCMASK  DS    0F                 MASK USED IN DETERMINING THE SPACING
         DC    XL4'00000001'      OF THE PSW +/- 6 BYTES OUTPUT
*
FILLCHAR DC    CL16'****************'
*
MOVEWORK MVC   ABWORK1(0),0(R7)   OBTAIN A BYTE OF MEMORY TO PRINT
MOVEVALS MVC   0(0,R9),ABWORK2    MOVE RESULT TO MESSAGE AREA
MAXBLOCK DC    F'4'
*
ABTRAN   DC    C'0123456789ABCDEF'
*
* THIS IOB TEMPLATE IS MOVED INTO THE 4K USER REGION. IT CONTAINS ALL
* OF THE DEFAULT VALUES FOR EACH IOB FIELD.
*
IOBMASK  DS    0F
         DC    CL4'IOB '          I/O BLOCK IDENTIFIER
         DC    X'000F'            ABEND OUTPUT WILL GO TO VIRT PRINT 2
         DC    X'01AA'            MESSAGE PRINT REQUEST
         DC    A(0)               ADDRESS OF MESSAGE TO BE PRINTED
         DC    H'133'             LENGTH OF EACH MESSAGE IS 133 BYTES
*
         DROP  R2,R6
*
         EQUREGS
         END   MYSVC13
/*
//*
//*
//* THIS IS THE ASSIST/V STEP, WHICH ACTUALLY ASSEMBLES AND RUNS SOS-D.
//*
//*
//ASSISTV EXEC PGM=ASSISTV,                                            X
//             PARM='P=100,PX=25,R=7000,RX=5000,L=150,T=15',           X
//             REGION=512K
//*
//STEPLIB  DD DSN=USER1.ASSIST.LOADLIB,DISP=SHR
//*
//*
//FT06F001 DD SYSOUT=A
//SYSPRINT DD SYSOUT=A
//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR
//         DD DSN=SYS2.MACLIB,DISP=SHR
//         DD DSN=T90RPR1.CS468PUB.MACLIB,DISP=SHR
//SYSIN    DD *
*SYSLIB LOADERC,DSECTS,EQUREGS,EQUCCWS
         TITLE 'SMALL OPERATING SYSTEM VERSION ==> C <==='
******
*
*    MACRO: GETCB100
*
* FUNCTION: TO OBTAIN A CONTROL BLOCK (TO BE USED AS A TCB, RB, ETC.)
*           FROM THE CURRENT POOL.
*
******
         MACRO
&NAME    GETCB100 &CBREG=10,&WORKREG=11
&NAME    L     &WORKREG,CVTC100H  LOAD ADDRESS OF CB100HDR FROM CVT
         L     &CBREG,0(&WORKREG) LOAD ADDRESS OF NEXT CONTROL BLOCK
         LTR   &CBREG,&CBREG      MAKE SURE A CB IS AVAILABLE
         BNZ   GTCB&SYSNDX
         XOPC  25                 STOP AND TAKE A DUMP
         DC    C'CB100 POOL IS EMPTY' LABEL THE ERROR
GTCB&SYSNDX MVC 0(4,&WORKREG),0(&CBREG) UPDATE THE CB100 POOL HEADER
         MEND
******
*
*    MACRO: FRECB100
*
* FUNCTION: TO FREE A CONTROL BLOCK THAT WHOSE USEFULNESS HAS EXPIRED.
*
******
         MACRO
&NAME    FRECB100 &CBREG=10,&WORKREG=11
&NAME    L     &WORKREG,CVTC100H  LOAD ADDRESS OF CB100HDR FROM CVT
         MVC   0(4,&CBREG),0(&WORKREG) LOAD ADD. OF NEXT TCB IN CHAIN
         ST    &CBREG,0(&WORKREG) POINT HEADER TO THIS CONTROL BLOCK
         MEND
******
*
*    MACRO: POPRQE
*
* FUNCTION: TO REMOVE AN RQE FROM THE CURRENT RQE CHAIN FOR THE GIVEN
*           UCB. ADDRESSABILITY INTO THE UCB AND RQE DESCTS IS ASSUMED.
*
******
         MACRO
&NAME    POPRQE &CBREG=10
&NAME    L     &CBREG,UCBWARQE    LOAD ADDRESS OF 1ST RQE WAITING
         LTR   &CBREG.,&CBREG     IS THERE AN RQE WAITING?
         BZ    GRQE&SYSNDX        IF NOT THEN RETURN RQE ADDR OF ZERO
         MVC   UCBWARQE,RQENRQE   POINT HEADER TO THIS CONTROL BLOCK
GRQE&SYSNDX DS 0H
         MEND
******
*
* THIS MACRO IS USED TO GENERATE CHANNEL COMMAND WORDS.
*
******
         MACRO
&NAME    CCW &CMD,&BUFFER,&FLAG,&LENGTH
&NAME    DC 0D'0',AL1(&CMD),AL3(&BUFFER),AL1(&FLAG),X'0',AL2(&LENGTH)
         MEND
         EJECT
*
* DSECT FOR REFERENCING CONTROL BLOCK ITEMS.
*
         DSECTS
*
* THIS DSECT IS USED TO REFERENCE THE 256 BYTE WORK AREA THAT IS SET
* ASIDE IN EACH USER REGION FOR SVC 13.
*
SVC13WRK DSECT
ABNDOUT  DS    CL133
ABNDCODE DS    F                  REG1 ON ENTRY TO SVC 13
ABWORK1  DS    D,CL1              WORK FIELD FOR MAKING HEX VALUES
ABWORK2  DS    F,CL1              PRINTABLE
ABWORK3  DS    F                  WORK FIELD
*
* THIS I/O BLOCK IS USED FOR ISSUING MESSAGES VIA SVC 0
*
ABENDIOB DS    0F
         DS    CL4                I/O BLOCK IDENTIFIER
         DS    XL2                XREAD/XPRNT CODE (NON-CHANNEL)
         DS    XL2                MESSAGE PRINT REQUEST
ABMSGADD DS    A(0)               ADDRESS OF MESSAGE TO BE PRINTED
         DS    H                  LENGTH OF EACH MESSAGE IS 133 BYTES
*
         EQUCCWS
*
         EQUREGS
         EJECT
******
*
*   MODULE: FIRST4K
*
* FUNCTION: TO SET UP 'LOW CORE' FOR THE SOS ASSIGNMENT, SUCH AS
*           THE FIVE NEW PSWS DISABLED FOR I/O, ENABLED FOR TIMER,
*           ALL PROGRAM, AND MACHINE INTERRUPTS, KEY ZERO, SUPERVISOR
*           STATE, AND  WITH THE ADDRESS OF THE APPROPRIATE FIRST
*           LEVEL INTERRUPT HANDLER CONTAINED IN THE ADDRESS PORTION.
*           ONCE ASSEMBLED, THE IPL PSW IS LOADED FROM LOCATION 0,
*           WHICH GIVES CONTROL TO THE IPL PROGRAM.
*
*     NOTE: THIS MODULE CONTAINS NO EXECUTABLE CODE.
*
******
FIRST4K  CSECT
*
* SINCE THE CONTROL BLOCKS WITHIN THIS MODULE WILL RESIDE WITHIN
* THE FIRST 4K OF STORAGE, WE DO NOT EVEN NEED A BASE REGISTER, SINCE
* ABSOLUTE ADDRESSING WOULD WORK. HOWEVER, WE WILL ASSIGN REGISTER 0 AS
* A PSEUDO-BASE REGISTER WHICH WILL FACILITATE THIS ABSOLUTE ADDRESSING
* WHILE GIVING THE ASSEMBLER A BASE REGISTER BY WHICH WE MAY REFERENCE
* STORAGE USING LABELS.
*
         USING FIRST4K,R0         SET UP A PSEUDO-BASE REGISTER
*
         DC    2048X'0119'        FILL FIRST 4K WITH XOPC 25 INSTRS..
*
* HERE WE WILL DEFINE THE PSW WHICH POINTS TO THE IPL PROGRAM.
*
         ORG   FIRST4K
         DC    X'010401190F',AL3(IPLPGM)
*
* THE FOLLOWING IS THE ADDRESS OF THE CVT.
*
         ORG   FIRST4K+X'10'
         DC    A(CVTABLE)
*
* THESE ARE THE OLD PSW STORAGE AREAS FOR EACH TYPE OF INTERRUPT.
*
         ORG   FIRST4K+X'18'
OLDTYPE1 DC    4X'0119'            EXTERNAL INTERRUPT OLD PSW
OLDTYPE2 DC    4X'0119'            SVC INTERRUPT OLD PSW
OLDTYPE3 DC    4X'0119'            PROG CHECK INTERRUPT OLD PSW
OLDTYPE4 DC    4X'0119'            REPRESS. MACH CHK INTERRUPT
OLDTYPE5 DC    4X'0119'            I/O INTERRUPT OLD PSW
*
* THE FOLLOWING IS THE BACKUP ADDRESS OF THE CVT. WE WILL USUALLY
* GET THE ADDRESS FROM THIS LOCATION.
*
         ORG   FIRST4K+X'4C'
         DC    A(CVTABLE)
         EJECT
*
* THIS IS THE INITIAL TIMER VALUE. IT MUST BE FILLED IN AGAIN BY THE
* IPL PROGRAM BEFORE A TIMER INTERRUPT OCCURS AND CAUSES AN ABEND.
*
         ORG   FIRST4K+X'50'
         DC    F'0'
*
* AND NOW WE WILL DEFINE THE PSW FOR EACH TYPE OF INTERRUPT, POINTING
* TO THE APPROPRIATE INTERRUPT HANDLER. THE FIVE NEW PSWS DISABLED
* FOR I/O, ENABLED FOR TIMER, ALL PROGRAM, AND MACHINE INTERRUPTS,
* KEY ZERO, SUPERVISOR STATE, AND  WITH THE ADDRESS OF THE APPROPRIATE
* FIRST LEVEL INTERRUPT HANDLER CONTAINED IN THE ADDRESS PORTION.
*
         ORG   FIRST4K+X'58'
NEWTYPE1 DC    X'010401190F',AL3(ITYPE1) EXTERNAL INTERRUPT NEW PSW
NEWTYPE2 DC    X'010401190F',AL3(SVCFLIH) SVC INTERRUPT NEW PSW
NEWTYPE3 DC    X'010401190F',AL3(PCHKFLIH) PROG CHECK INTERRUPT NEW PSW
NEWTYPE4 DC    X'010401190F',AL3(ITYPE4) REPRESS. MACH CHK INTERRUPT
NEWTYPE5 DC    X'010401190F',AL3(IOFLIH) I/O INTERRUPT NEW PSW
*
         ORG   FIRST4K+X'C0'
LEVELABN DC    X'0119'
LEVELFLG DC    CL1' '
TYP1FLAG DC    CL1' '
*
         ORG   FIRST4K+X'E0'
LOWPSW   DC    4X'0119'
*
         ORG   FIRST4K+X'F0'
LOWTIME  DC    4X'0119'
*
* THESE ARE THE GPR SAVE AREAS FOR INTERRUPT TYPES 1, 2, 3, AND 5.
*
         ORG   FIRST4K+X'100'
TYP1SAVE DC    16F'-1'            EXTERNAL INTERRUPT
TYP2SAVE DC    16F'-2'            SVC INTERRUPT
TYP3SAVE DC    16F'-3'            PROGRAM CHECK INTERRUPT
TYP5SAVE DC    16F'-4'            I/O INTERRUPT
*
         EJECT
*
* THIS IS THE LOCATION OF TCBWORDS. THE DSECT IEATCBP IS USED TO
* MAP THIS ITEM.
*
         ORG   FIRST4K+X'218'
TCBWORDS DC    4A(0)
         EJECT
*
*   >     U   U CCCCC BBBB     CCCCC H   H   A   IIIII N   N     <
*    >    U   U C     B   B    C     H   H  A A    I   NN  N    <
*     >   U   U C     BBBB     C     HHHHH A   A   I   N N N   <
*    >    U   U C     B   B    C     H   H AAAAA   I   N  NN    <
*   >     UUUUU CCCCC BBBB     CCCCC H   H A   A IIIII N   N     <
*
*
         ORG   FIRST4K+X'800'
UCB000C  DC    CL3'UCB',X'FF'     UCB IDENTIFIER
         DC    X'000C'            DEVICE ADDRESS OF VIRTUAL READER 1
         DC    X'00'              X'00' = FREE, X'FF' = BUSY
         DC    X'00'              RESERVED
         DC    A(UCB000D)         ADDRESS OF NEXT UCB IN CHAIN
         DC    CL4'000C'          DEVICE ADDRESS IN PRINTABLE FORM
         DC    A(0)               ADDRESS OF CURRENT RQE
         DC    A(0)               ADDRESS OF RQE IN WAIR QUEUE
         DC    A(SIO000C)         ADDRESS OF DEVICE I/O START RTN
         DC    A(0)               RESERVED
*
UCB000D  DC    CL3'UCB',X'FF'     UCB IDENTIFIER
         DC    X'000D'            DEVICE ADDRESS OF VIRTUAL READER 2
         DC    X'00'              X'00' = FREE, X'FF' = BUSY
         DC    X'00'              RESERVED
         DC    A(UCB000E)         ADDRESS OF NEXT UCB IN CHAIN
         DC    CL4'000D'          DEVICE ADDRESS IN PRINTABLE FORM
         DC    A(0)               ADDRESS OF CURRENT RQE
         DC    A(0)               ADDRESS OF RQE IN WAIR QUEUE
         DC    A(SIO000D)         ADDRESS OF DEVICE I/O START RTN
         DC    A(0)               RESERVED
*
UCB000E  DC    CL3'UCB',X'FF'     UCB IDENTIFIER
         DC    X'000E'            DEVICE ADDRESS OF VIRTUAL PRINTER 1
         DC    X'00'              X'00' = FREE, X'FF' = BUSY
         DC    X'00'              RESERVED
         DC    A(UCB000F)         ADDRESS OF NEXT UCB IN CHAIN
         DC    CL4'000E'          DEVICE ADDRESS IN PRINTABLE FORM
         DC    A(0)               ADDRESS OF CURRENT RQE
         DC    A(0)               ADDRESS OF RQE IN WAIR QUEUE
         DC    A(SIO000E)         ADDRESS OF DEVICE I/O START RTN
         DC    A(0)               RESERVED
*
UCB000F  DC    CL3'UCB',X'FF'     UCB IDENTIFIER
         DC    X'000F'            DEVICE ADDRESS OF VIRTUAL PRINTER 1
         DC    X'00'              X'00' = FREE, X'FF' = BUSY
         DC    X'00'              RESERVED
         DC    A(0)               ADDRESS OF NEXT UCB IN CHAIN
         DC    CL4'000F'          DEVICE ADDRESS IN PRINTABLE FORM
         DC    A(0)               ADDRESS OF CURRENT RQE
         DC    A(0)               ADDRESS OF RQE IN WAIR QUEUE
         DC    A(SIO000F)         ADDRESS OF DEVICE I/O START RTN
         DC    A(0)               RESERVED
         EJECT
*
*         >     CCCCC BBBB     PPPPP OOOOO OOOOO L        <
*          >    C     B   B    P   P O   O O   O L       <
*           >   C     BBBB     PPPPP O   O O   O L      <
*          >    C     B   B    P     O   O O   O L       <
*         >     CCCCC BBBB     P     OOOOO OOOOO LLLLL    <
*
*
* THESE ARE THE CONTROL BLOCKS TO BE USED AS RBS, TCBS, ETC.
* (THEY ALL HAVE THE SAME FORMAT). THERE MAY BE UP TO 15.
*
CB100LTH EQU   X'100'
CB100#   EQU   22
         ORG   FIRST4K+X'1900'
CB100HDR DC    A(0),CL28'THE CB100 POOL FOLLOWS THIS'
         ORG   FIRST4K+((*-FIRST4K+255)/256*256)
CB100POL DC    (CB100#)CL(CB100LTH)'1234-JOE KESSLER-UNUSED CB'
         EJECT
*
*  >    TTTTT   A   SSSSS K   K     IIIII N   N FFFFF OOOOO     <
*   >     T    A A  S     K  K        I   NN  N F     O   O    <
*    >    T   A   A SSSSS KKK         I   N N N FFFF  O   O   <
*   >     T   AAAAA     S K  K        I   N  NN F     O   O    <
*  >      T   A   A SSSSS K   K     IIIII N   N F     OOOOO     <
*
* THIS ROUTINE IS CALLED UPON TERMINATION OF A GIVEN TASK.
*
* THIS SUBROUTINE WILL PRINT OUT INFORMATION ON PERTAINING TO A GIVEN
* TASK. PARTICULARLY, IT WILL PRINT OUT THE TASK NAME, PROGRAM NAME,
* ALL OF THE TCB TIME FIELD VALUES, THE TOTAL TASK I/O COUNTS, AND THE
* I/O COUNT FOR EACH OF THE FOUR VIRTUAL DEVICES.
*
* ON ENTRY TO THIS SUBROUTINE, THE FOLLOWING REGISTER VALUES SHOULD
* APPLY:
*
*   REG 2 = DEVICE ADDRESS AT WHICH TO SEND OUTPUT (0 FOR XPRNT)
*   REG 4 = ADDRESS OF THE TCB FOR THE TASK TO BE REPORTED ON
*   REG 12 = ADDRESS OF ENTRY POINT TO THIS MODULE
*   REG 14 = RETURN ADDRESS TO CALLING ROUTINE.
*
* THIS ROUTINE DOES NOT RETURN ANY VALUES; THE REGISTER VALUES UPON
* EXIT WILL BE UNCHANGED FROM THE REGISTER VALUES UPON ENTRY.
*
         ORG   FIRST4K+X'3000'
TASKINFO DS    0H
         USING TASKINFO,R12       ESTABLISH ADDRESSABILITY INTO MODULE
         USING TCB,R4             AND INTO THE TASK CONTROL BLOCK
*
         STM   R0,R15,TISAVE1     SAVE CALLING ROUTINE'S REGISTERS
*
* WE ARE READY TO PRINT OUT THE FIRST OF THREE MESSAGE LINES PRODUCED
* BY THIS MODULE. THE FIRST ONE CONTAINS THE TASK NAME AND PROGRAM
* NAME OF THE TASK IN QUESTION.
*
         STH   R2,TIDEVAD         STORE ADDRESS OF TARGET DEVICE
*
         MVC   TASKIN1+41(8),TCBTNAME MOVE THE TASK NAME TO MSG LINE
         MVC   TASKIN1+60(8),TCBPNAME MOVE PGM NAME TO MSG LINE
         MVC   TASKINLN(133),TASKIN1  MOVE ENTIRE MSG LINE TO BUFFER
         BAL   R10,TASKPRNT         PRINT THE FIRST LINE OF OUTPUT
*
* THE LAST TWO LINES CONTAIN NUMERIC VALUES FOUND WITHIN THE TCB. THE
* SECOND LINE CONTAINS THE FIVE TCB TIMING FIELDS, WHILE THE THIRD
* CONTAINS THE TOTAL I/O COUNTS AND I/O COUNTS BY DEVICE. THESE FIELDS
* MUST BE CONVERTED FROM BINARY TO A PRINTABLE FORM.
*
* WE WILL PRINT OUT THE TCB TIME FIELDS FIRST.
*
         LA    R5,TITRAN          REG 5 POINTS TO THE TRANSLATE TABLE
         LA    R0,240             ADJUST FOR A CONDENSED XLATE TABLE
         SR    R5,R0
*
         UNPK  TASKIN2+41(9),TCBTWALS(5)  CONVERT THE TCBTWALS FIELD
         TR    TASKIN2+41(9),0(R5)        TO PRINTABLE FORMAT
         MVI   TASKIN2+49,C' '
*
         UNPK  TASKIN2+58(9),TCBTCPUP(5)  CONVERT THE TCBTDISP FIELD
         TR    TASKIN2+58(9),0(R5)        TO PRINTABLE FORMAT
         MVI   TASKIN2+66,C' '
*
         UNPK  TASKIN2+75(9),TCBTCPUS(5)  CONVERT THE TCBTCPUP FIELD
         TR    TASKIN2+75(9),0(R5)        TO PRINTABLE FORMAT
         MVI   TASKIN2+83,C' '
*
         UNPK  TASKIN2+92(9),TCBTSYS(5)   CONVERT THE TCBTCPUS FIELD
         TR    TASKIN2+92(9),0(R5)        TO PRINTABLE FORMAT
         MVI   TASKIN2+100,C' '
*
         UNPK  TASKIN2+109(9),TCBTWAIT(5) CONVERT THE TCBTWAIT FIELD
         TR    TASKIN2+109(9),0(R5)       TO PRINTABLE FORMAT
         MVI   TASKIN2+117,C' '
*
         MVC   TASKINLN(133),TASKIN2 MOVE CONVERTED FIELDS TO BUFFER
         BAL   R10,TASKPRNT        PRINT OUT TCB TIME VALUES
*
* WE ARE NOW READY TO PRINT OUT THE FINAL LINE OF TASK INFORMATION,
* WHICH CONTAINS THE TOTAL I/O COUNTS FOR THE TASK, AND I/O COUNTS BY
* DEVICE.
*
         UNPK  TASKIN3+41(9),TCBTSLIC+4(5)  CONVERT TOTAL I/O COUNT
         TR    TASKIN3+41(9),0(R5)          TO PRINTABLE FORMAT
         MVI   TASKIN3+49,C' '
*
         UNPK  TASKIN3+58(9),TCBTSLIC+8(5)  CONVERT VIRTUAL RDR 1 I/O
         TR    TASKIN3+58(9),0(R5)          COUNT TO PRINTABLE FORMAT
         MVI   TASKIN3+66,C' '
*
         UNPK  TASKIN3+75(9),TCBTSLIC+12(5) CONVERT VIRTUAL RDR 2 I/O
         TR    TASKIN3+75(9),0(R5)          COUNT TO PRINTABLE FORMAT
         MVI   TASKIN3+83,C' '
*
         UNPK  TASKIN3+92(9),TCBTSLIC+16(5) CONVERT VIRTUAL PRT 1 I/O
         TR    TASKIN3+92(9),0(R5)          COUNT TO PRINTABLE FORMAT
         MVI   TASKIN3+100,C' '
*
         UNPK  TASKIN3+109(9),TCBTSLIC+20(5) CONVERT VIRTUAL PRT 2 I/O
         TR    TASKIN3+109(9),0(R5)          COUNT TO PRINTABLE FORMAT
         MVI   TASKIN3+117,C' '
*
         MVC   TASKINLN(133),TASKIN3 MOVE I/O COUNT VALUES TO BUFFER
         BAL   R10,TASKPRNT          PRINT OUT TCB TIME VALUES
*
* PRINT OUT THE FINAL INFORMATIVE MESSAGE WHICH STATES THAT THE
* JOB HAS INDEED BEEN TERMINATED.
*
         MVI   TASKINLN,C' '      CLEAR OUT THE MESSAGE LINE
         MVC   TASKINLN+1(132),TASKINLN
*
         MVC   TASKINLN(40),TASKIN4 MOVE IN THE FINAL TERMINATION MSG
         BAL   R10,TASKPRNT         PRINT OUT THE MESSAGE LINE
*
* BRANCH BACK TO THE CALLING ROUTINE.
*
         LM    R0,R15,TISAVE1     RESTORE CALLER'S REG VALUES
         BR    R14
*
* THIS SMALL SUBROUTINE IS USED TO PRINT OUT A MESSAGE LINE. SINCE WE
* MAY BE AT THE SYSTEM LEVEL, WE MUST USE A BRANCH ENTRY TO THE SVC 0
* I/O MODULE.
*
* UPON ENTRY TO THIS ROUTINE, REG 10 SHOULD CONTAIN THE RETURN ADDRESS.
*
TASKPRNT DS    0H
         CLI   LEVELFLG,C'S'      ARE WE AT THE SYSTEM LEVEL?
         BE    BRSVC0             IF SO THEN WE MUST USE BRANCH ENTRY
*
         LA    R1,TASKIOB         POINT TO MESSAGE I/O BLOCK FOR SVC 0
         XOPC  4
         SVC   0                  OTHERWISE, WE MAY USE SVC DIRECTLY
         XOPC  2
         B     SVCRTN             CHECK THE SVC 0 RETURN CODE
*
BRSVC0   DS    0H
         STM   R0,R15,TISAVE2     STORE REGS BEFORE BRANCH TO SVC 0
*                                 SINCE ANY OF THEM MAY BE DESTROYED
         L     R3,76              GET ADDRESSABILITY INTO THE CVT
         USING CVT,R3
         LA    R1,TASKIOB         POINT TO MESSAGE I/O BLOCK FOR SVC 0
         L     R6,CVTSVCTA        OBTAIN ADDRESS OF THE SVC TABLE
         L     R6,0(,R6)          OBTAIN ADDRESS OF SVC 0 MODULE
*
         XOPC  4                  TURN OF TRACE TEMPORARILY
         BALR  R14,R6             BRANCH TO THE SVC 0 MODULE
         XOPC  2                  TURN TRACE BACK ON WITH PREV. PARMS
*
         L     R3,76              ENSURE ADDRESSABILITY INTO THE CVT
*
         L     R12,CVTSUB1        RE-ESTABLISH ADDRESSABILITY
         LM    R0,R14,TISAVE2     RESTORE REGS BEFORE SVC 0
*
SVCRTN   DS    0H
         LTR   R15,R15            WAS THE I/O SUCCESSFUL?
         BNZ   BADMSGIO           IF NOT THEN ABEND WITH A DUMP
         BR    R10                RETURN TO THE MAIN PROGRAM BODY
         DROP R3
*
BADMSGIO DS    0H
         XOPC  25
         DC    C'BAD IOB IN ''JOB END'' MESSAGE ROUTINE'
*
TISAVE1  DC    16F'-1'            REG VALUES OF CALLING ROUTINE
TISAVE2  DC    16F'-1'            REG VALUES BEFORE BRANCH TO SVC 0
*
TITRAN   DC    C'0123456789ABCDEF' NUMERIC VALUE TRANSLATION TABLE
*
TASKIOB  DS    0F
         DC    CL4'IOB '          I/O BLOCK IDENTIFIER
TIDEVAD  DC    X'0000'            PRINT TO DEVICE AT @ PASSED IN REG 2
         DC    X'01AA'            MESSAGE PRINT REQUEST
         DC    A(TASKINLN)        ADDRESS OF MESSAGE TO BE PRINTED
         DC    H'133'             LENGTH OF EACH MESSAGE IS 60 BYTES
TASKINLN DC    CL133' '           MESSAGE OUTPUT LINE
*
TASKIN1  DC CL133'-*** JAK SOS-D  JOB TERMINATION OF TASK:           PRX
               OGRAM:         '
TASKIN2  DC CL133'                TASK TIMES        TWALS:           TCX
               PUP:           TCPUS:            TSYS:           TWAIT: X
                        '
TASKIN3  DC CL133'                TASK I/O COUNTS   TOTAL:            RX
               DR1:            RDR2:            PRT1:            PRT2: X
                        '
TASKIN4  DC CL40'                >>> JOB HAS ENDED <<<'
         DROP R12
         EJECT
*
* EXIGENT MACHINE CHECK INTERRUPT HANDLER.
*
ITYPE1   DS   0H
         XOPC 25
         DC    CL30'THIS WAS AN EXTERNAL INTERRUPT'
*
* REPRESSIBLE MACHINE CHECK INTERRUPT HANDLER.
*
         ORG   FIRST4K+((*-FIRST4K+31)/32*32)
ITYPE4   XOPC 25
         DC    CL30'THIS WAS A MACH CHK INTERRUPT'
         EJECT
*
*    >      IIIII     / OOOOO      FFFFF L     IIIII H   H      <
*     >       I      /  O   O      F     L       I   H   H     <
*      >      I     /   O   O      FFFF  L       I   HHHHH    <
*     >       I    /    O   O      F     L       I   H   H     <
*    >      IIIII /     OOOOO      F     LLLLL IIIII H   H      <
*
*
* THIS IS THE I/O FIRST LEVEL INTERRUPT HANDLER. IT RECEIVES CONTROL
* AS A RESULT OF THE COMPLETION OF AN I/O EVENT.
*
* REGISTER USAGE:
*
*   REG 0 = USAGE NOT DEFINED
*   REG 1 = USAGE NOT DEFINED
*   REG 2 = USAGE NOT DEFINED
*   REG 3 = ADDRESS OF THE CVT
*   REG 4 = ADDRESS OF THE CURRENT TCB
*   REG 5 = ADDRESS OF THE CURRENT RB
*   REG 6 = USAGE NOT DEFINED
*   REG 7 = USAGE NOT DEFINED
*   REG 8 = USAGE NOT DEFINED
*   REG 9 = USAGE NOT DEFINED
*   REG 10 = USAGE NOT DEFINED
*   REG 11 = USAGE NOT DEFINED
*   REG 12 = BASE REGISTER
*   REG 13 = USAGE NOT DEFINED
*   REG 14 = USAGE NOT DEFINED
*   REG 15 = USAGE NOT DEFINED
*
         ORG   FIRST4K+((*-FIRST4K+31)/32*32)
IOFLIH   DS    0D
*
* MOVE CURRENT TIMER VALUE TO LOW STORAGE AREA.
*
         MVC   LOWTIME(4),X'50'   COPY TIMER VALUE TO SAFE LOCATION
*
* NOW WE WILL SAVE THE USER'S REGISTERS SO THAT WE CAN DO SOME WORK.
*
         STM   R0,R15,TYP5SAVE    STORE USER REGISTERS FOR LATER USE
*
* THE I/O INTERRUPT SHOULD HAVE OCCURRED FROM WITHIN THE TASK
* MODE. IF NOT, THEN THIS MAY BE A LOGIC ERROR AND WE SHOULD ABEND WITH
* A DUMP.
*
         CLI   LEVELFLG,C'T'      ABEND SHOULD HAVE BEEN AT TASK LEVEL
         BNE   LEVELABN           IF NOT, ABEND WITH A DUMP
         MVI   LEVELFLG,C'S'      OTHERWISE, SET LEVEL TO 'SYSTEM'
*
* ESTABLISH ADDRESSABILITY INTO THIS MODULE.
*
         BALR  R12,R0             ESTABLISH A BASE REGISTER
         USING *,R12
*
* WE WILL NOW OBTAIN THE "STANDARD" REGISTER VALUE FOR THE INTERRUPT
* HANDLER. THESE ARE DEFINED AS FOLLOWS:
*
*  REG 3 = ADDRESS OF THE CVT (OBTAINED FROM BACKUP COPY AT X'4C')
*  REG 4 = ADDRESS OF THE CURRENT TCB
*  REG 5 = ADDRESS OF THE CURRENT RB
*
* ONCE WE HAVE THESE VALUES, WE CAN ALSO SET UP ADDRESSIBILITY INTO
* OUR DSECTS.
*
         L     R3,X'4C'           GET @ OF THE CVT
         L     R4,0(,R3)          GET @ OF TCB WORDS
         L     R4,4(,R4)          GET @ OF THE CURRENT TCB
         L     R5,0(,R4)          GET @ OF THE CURRENT RB
         USING CVT,R3             ESTABLISH ADDRESSIBILITY INTO CVT
         USING TCB,R4             ESTABLISH ADDRESSIBILITY INTO TCB
         USING RB,R5              ESTABLISH ADDRESSIBILITY INTO RB
*
* IF REG 5 CONTAINS ZERO THEN IT DOES NOT POINT TO A VALID RB, AND
* WE WILL ABEND ACCORDINGLY WITH A DUMP.
*
         LTR   R5,R5              IS THE REQUEST BLOCK @ INVALID?
         BZ    IORBERR            IF SO THEN ABEND WITH A DUMP
*
* NOW WE WILL SAVE THE USER'S REGISTERS IN THE TCB SAVE AREAS ALLOTTED.
*
         MVC   TCBGRS(16*4),TYP5SAVE
         STD   0,TCBFRS           STORE THE FOATING POINT REGISTERS
         STD   2,TCBFRS+1*8
         STD   4,TCBFRS+2*8
         STD   6,TCBFRS+3*8
*
* WE WILL ALSO STORE THE USER'S PSW INTO THE RB SO THAT THE TCB
* MAY LATER BE RE-DISPATCHED.
*
         MVC   RBOPSW(8),OLDTYPE5 STORE OLD PSW IN REQUEST BLOCK
*
* NOW WE WILL COMPUTE A VALUE TO BE ADDED TO TCBTCPU. THIS IS THE
* TOTAL CPU TIME ELAPSED BETWEEN DISPATCH OF THE RB AND THIS SVC.
*
         L     R8,TCBTDISP        GET CPU TIME AT DISPATCH
         S     R8,LOWTIME         SUBTRACT CPU TIME AT SVC INTERRUPT
         TM    OLDTYPE5+1,X'01'   WAS INTERRUPT IN SUPERVISOR STATE?
         BZ    ADDSTM5            IF SO THEN ADD TIME TO SUP. TOTAL
*
         A     R8,TCBTCPUP        ADD ELAPSED CPU TIME TO TCB TOTAL
         ST    R8,TCBTCPUP        AND STORE IT BACK INTO THE TCB FIELD
         B     TESTCSW            BRANCH TO I/O PROCESSING CODE
*
ADDSTM5  DS    0H
         A     R8,TCBTCPUS        ADD ELAPSED CPU TIME TO TCB TOTAL
         ST    R8,TCBTCPUS        AND STORE IT BACK INTO THE TCB FIELD
*
* FIRST, WE WILL CHECK THE CSW FLAGS FOR ANY SIGNS OF AN ERROR.
* ANY FLAGS OTHER THAN CHANNEL, CONTROL UNIT, OR DEVICE END, UNIT
* EXCEPTION, AND ATTENTION WILL CAUSE AN ABEND WITH A DUMP.
*
TESTCSW  DS    0H
         TM    X'44',255-CUE-CE-DE-UE TEST FOR ANY "BAD" BITS
         BZ    GOODCSW            IF NONE ARE SET THEN ALL IS WELL
         B     BADCSW             OTHERWISE, WE WILL ABEND WITH A DUMP
*
GOODCSW  DS    0H
         TM    X'44',DE           WE MUST HAVE DEVICE END INDICATOR
         BZ    GOTODISP           IF NOT THEN THE I/O IS NOT DONE YET
*
* HERE, WE WILL DO SOME ADDITIONAL TESTS, SUCH AS EXAMINING THE CHANNEL
* STATUS BITS (THEY SHOULD BE 0), THE ADDRESS OF THE NEXT CCW, AND THE
* RESIDUAL LENGTH.
*
         TM    X'45',255          ARE ANY OF THE CHAN. STATUS BITS SET?
         BNZ   BADCSW             IF SO THEN WE HAVE A CHANNEL ERROR
*
         LH    R2,X'46'           GET THE RESIDUAL COUNT FROM CSW
         LTR   R2,R2              IS THE RESIDUAL COUNT ZERO?
         BNZ   BADCSW             IF NOT THEN ABEND WITH A DUMP
*
* NOW WE WILL RUN THE CHAIN OF UCBS, LOOKING FOR THE UCB ASSOCIATED
* WITH THE DEVICE THAT JUST CAUSED THE INTERRUPT.
*
         L     R7,CVTUCBS         GET ADDRESS OF FIRST UCB IN CHAIN
         USING UCB,R7             SET UP ADDRESSABILITY INTO THE UCB
SCANUCBS DS    0H
         LTR   R7,R7              DID WE HIT THE END OF THE CHAIN?
         BZ    IODEVERR           IF SO THEN BAD DEVICE ADDRESS
*
         CLC   OLDTYPE5+2(2),UCBCHAN DOES THE DEVICE ADDRESS MATCH?
         BE    FNDUCB                IF SO THEN PROCESS THE UCB
*
         L     R7,UCBUCB          OTHERWISE, POINT TO NEXT UCB
         B     SCANUCBS
*
* AT THIS POINT, WE HAVE DETERMINED THAT THE I/O OPERATION HAS
* BEEN COMPLETED. WE WILL THUS REMOVE THE RQE FROM THE RQE CHAIN
* ASSOCIATED WITH THE PROPER UCB, AND MAKE THE USER'S RB DISPATCHABLE
* ONCE AGAIN. WE WILL THEN BRANCH TO THE BEGIN I/O ROUTINE, TO CHECK
* IF ANY OTHER PENDING I/O OPERATION CAN BE STARTED.
*
FNDUCB   DS    0H
         L     R2,UCBIOSTR        GET ADDRESS OF START I/O RTN
         CLC   X'41'(3),5(R2)     DID THE ENTIRE CHANNEL PGM RUN?
         BNE   BADCSW             IF NOT THEN ABEND WITH A DUMP
*
         L     R10,UCBCURQE       GET THE ADDR. OF THE CURRENT RQE
         USING RQE,R10            SET UP ADDRESSABILITY INTO RQE
         L     R1,RQEIOB          GET ADDRESS OF THE ORIGINAL IOB
         USING IOB,R1             SET UP ADDRESSABILITY INTO THE IOB
*
         L     R4,RQETCB          GET ADDRESS OF TCB FOR THIS UCB
         L     R5,RQERB           GET ADDRESS OF RB FOR THIS RQE
*
* NOW WE WILL COMPUTE THE WAIT TIME ELAPSED SINCE THE I/O OPERATION
* ORIGINALLY BEGAN.
*
         L     R8,TCBTSSIO        GET CPU TIME AT DISPATCH
         S     R8,LOWTIME         SUBTRACT CPU TIME AT SVC INTERRUPT
         A     R8,TCBTWAIT        ADD ELAPSED CPU TIME TO TCB TOTAL
         ST    R8,TCBTWAIT        AND STORE IT BACK INTO THE TCB FIELD
*
* HERE, WE WILL TEST FOR END OF FILE BY CHECKING THE UNIT EXCEPTION BIT
* IN THE CSW. END-OF-FILE IS ALSO ASSUMED IF THIS WAS A READ OPERATION
* AND THE FIRST 8 BYTES OF THE READ BUFFER CONTAIN 8C'8'.
*
         SR    R15,R15            BY DEFAULT, RETURN CODE IS 0
*
         CLI   IOBOPCDE,X'01'     WAS THIS I/O A PRINT OPERATION?
         BE    KILLRQE            IF SO THEN SET RC = 0
*
         L     R2,IOBUFADD        GET I/O BUFFER ADDRESS
         CLC   0(8,R2),EOFREC     1ST EIGHT COLUMNS FILLED WITH C'8'?
         BE    IOEOF              IF SO THEN WE HAVE HIT "EOF"
*
         TM    X'44',UE           TEST FOR UNIT EXCEPTION IN IOB
         BO    IOEOF              IF SET THEN WE HAVE HIT EOF
         B     KILLRQE            OTHERWISE JUST REMOVE THE RQE
*
IOEOF    DS    0H
         LA    R15,4              SEND BACK A RETURN CODE OF 4
*
* NOW WE WILL REMOVE THE RQE FROM THE RQE CHAIN AND DECREMENT THE RB
* WAIT COUNT FOR THE ASSOCIATED REQUEST BLOCK.
*
KILLRQE  DS    0H
         POPRQE CBREG=R10
         XC    UCBCURQE(4),UCBCURQE THERE IS NO CURRENT RQE
         FRECB100 CBREG=R10
*
         XR    R13,R13            CLEAR OUT A WORK REGISTER
         IC    R13,RBWCF          GET RB WAIT COUNT
         BCTR  R13,R0             DECREMENT WAIT COUNT BY ONE
         STC   R13,RBWCF          STORE THE NEW RB WAIT COUNT
*
         ST    R15,TCBGRS+15*4    STORE I/O RETURN CODE
*
         MVI   UCBFLA,X'00'       MARK THE UCB AS 'FREE'
*
* WHEN THE I/O OPERATION HAS BEEN COMPLETED SUCCESSFULLY, WE WILL GO
* BACK TO THE BEGIN I/O ROUTINE TO PROCESS ANY PENDING I/O REQUESTS.
*
         L     R6,CVTBGNIO        GET ADDRESS OF THE BEGIN I/O ROUTINE
         BR    R6                 BRANCH TO THE DISPATCHER
*
* IF THE I/O HAS NOT YET COMPLETED THEN WE WE BRANCH TO THE DISPATCHER
* INSTEAD OF TO THE BEGIN I/O ROUTINE.
*
GOTODISP DS    0H
         L     R6,CVT0DS          GET ADDRESS OF THE DISPATCHER
         BR    R6                 BRANCH TO THE DISPATCHER
*
* THIS IS WHERE WE GO IF THERE IS NO RB POINTED TO BY REG 5.
*
IORBERR  DS    0H
         XOPC  25                 ABEND WITH A DUMP
         DC    C'THERE IS NO RB FOR THE CURRENT TCB'
*
* WHEN THERE ARE "BAD" BITS SET IN THE CSW, CONTROL COMES TO THIS
* SECTION OF CODE.
*
BADCSW   DS    0H
         XOPC  25                 ABEND WITH A DUMP
         DC    C'CHANNEL/UNIT ERROR: CHECK CSW FIELDS'
*
* THIS IS WHERE WE GO IF THE DEVICE ADDRESS IS INVALID.
*
IODEVERR DS    0H
         XOPC  25                 ABEND WITH A DUMP
         DC    C'INVALID DEVICE ADDRESS'
*
EOFREC   DC    8C'9'
         EJECT
*
*       >      BBBB  RRRRR   A   BBBB  EEEEE N   N DDDD      <
*        >     B   B R   R  A A  B   B E     NN  N D   D    <
*         >    BBBB  RRRRR A   A BBBB  EEE   N N N D   D   <
*        >     B   B R R   AAAAA B   B E     N  NN D   D    <
*       >      BBBB  R  R  A   A BBBB  EEEEE N   N DDDD      <
*
*
* THIS SECTION OF CODE COMPRISES THE BRABEND MODULE. THE BRABEND
* IS INVOKED WHENEVER THERE IS AN ABEND AT SYSTEM LEVEL. IT IS A
* "BACK DOOR" TO THE SVC 13 ROUTINE, WHICH CANNOT BE CALLED DIRECTLY
* FROM A SYSTEM LEVEL MODULE.
*
* REGISTER USAGE:
*
*   REG 0 = USAGE NOT DEFINED
*   REG 1 = ABEND CODE TO BE PASSED TO SVC 13 MODULE
*   REG 2 = USAGE NOT DEFINED
*   REG 3 = ADDRESS OF THE CVT
*   REG 4 = ADDRESS OF THE CURRENT TCB
*   REG 5 = ADDRESS OF THE CURRENT RB
*   REG 6 = USAGE NOT DEFINED
*   REG 7 = USAGE NOT DEFINED
*   REG 8 = USAGE NOT DEFINED
*   REG 9 = USAGE NOT DEFINED
*   REG 10 = USAGE NOT DEFINED
*   REG 11 = USAGE NOT DEFINED
*   REG 12 = BASE REGISTER FOR THIS MODULE
*   REG 13 = USAGE NOT DEFINED
*   REG 14 = USAGE NOT DEFINED
*   REG 15 = USAGE NOT DEFINED
*
*
BRABEND  DS    0D
*
* SET UP ADDRESSABILITY INTO THIS MODULE.
*
         USING BRABEND,R15        ESTABLISH BASE & ADDRESSABILITY
*
* WE WILL NOW OBTAIN THE "STANDARD" REGISTER VALUE FOR THE INTERRUPT
* HANDLER. THESE ARE DEFINED AS FOLLOWS:
*
*  REG 3 = ADDRESS OF THE CVT (OBTAINED FROM BACKUP COPY AT X'4C')
*  REG 4 = ADDRESS OF THE CURRENT TCB
*  REG 5 = ADDRESS OF THE CURRENT RB
*
* ONCE WE HAVE THESE VALUES, WE CAN ALSO SET UP ADDRESSIBILITY INTO
* OUR DSECTS.
*
         L     R3,X'4C'           GET @ OF THE CVT
         L     R4,0(,R3)          GET @ OF TCB WORDS
         L     R4,4(,R4)          GET @ OF THE CURRENT TCB
         L     R5,0(,R4)          GET @ OF THE CURRENT RB
         USING CVT,R3             ESTABLISH ADDRESSIBILITY INTO CVT
         USING TCB,R4             ESTABLISH ADDRESSIBILITY INTO TCB
         USING RB,R5              ESTABLISH ADDRESSIBILITY INTO RB
*
* IF REG 5 CONTAINS ZERO THEN IT DOES NOT POINT TO A VALID RB, AND
* WE WILL ABEND ACCORDINGLY WITH A DUMP.
*
         LTR   R5,R5              IS THE REQUEST BLOCK @ INVALID?
         BZ    BRABERR            IF SO THEN ABEND WITH A DUMP
*
* OBTAIN AND INITIALIZE AN SVRB TO BECOME THE NEW CURRENT RB.
* WE WILL SIMPLY BRANCH TO THE SVC FLIH, WHICH ALREADY CONTAINS SVRB
* SCHEDULING CODE. HENCE, WE WILL NOT HAVE TO UNCESSARILY REPEAT
* THE SVRB LOGIC.
*
         L     R6,CVTSVCTA        GET @ OF THE SVC TABLE
         LA    R7,13*8            GET OFFSET OF SVC 13 RTN IN SVC TABLE
         AR    R6,R7              POINT REG 6 TO SVC 13 ENTRY
         L     R6,0(,R6)          GET THE ENTRY ADDRESS FOR SVC 13
*
* IF REG 6 CONTAINS ZERO THEN THERE IS NO SVC 13 ABEND MODULE, AND
* WE WILL ABEND ACCORDINGLY WITH A DUMP.
*
         LTR   R6,R6              IS THE SVC 13 MODULE ADDRESS NULL?
         BZ    NOSVC13            IF SO, ABEND WITH A DUMP
*
         L     R10,ADDRSVRB       GET @ OF SVRB SCHEDULER IN SVC FLIH
         BR    R10                BRANCH TO SVRB SCHEDULER
*
* THIS IS WHERE WE GO IF THERE IS NO RB POINTED TO BY REG 5.
*
BRABERR  DS    0H
         XOPC  25                 ABEND WITH A DUMP
         DC    C'THERE IS NO RB FOR THE CURRENT TCB'
*
* THIS IS WHERE WE GO IF THERE IS NO RB POINTED TO BY REG 5.
*
NOSVC13  DS    0H
         XOPC  25                 ABEND WITH A DUMP
         DC    C'SVC 13 DOES NOT EXIST'
*
ADDRSVRB DC    A(NONTYPE1)        ADDR OF SVRB SCHEDULER IN SVC FLIH
         EJECT
*
*   >     PPPPP CCCCC H   H K   K     FFFFF L     IIIII H   H     <
*    >    P   P C     H   H K  K      F     L       I   H   H    <
*     >   PPPP  C     HHHHH KKK       FFF   L       I   HHHHH   <
*    >    P     C     H   H K  K      F     L       I   H   H    <
*   >     P     CCCCC H   H K   K     F     LLLLL IIIII H   H     <
*
*
* THIS IS THE PROGRAM CHECK FIRST LEVEL INTERRUPT HANDLER. IT SIMPLY
* INVOKES SVC 13 TO CAUSE AN ABEND BY INVOKING THE BRABEND ROUTINE.
*
* REGISTER USAGE:
*
*   REG 0 = USAGE NOT DEFINED
*   REG 1 = ABEND CODE FOR SVC 13 ABEND ROUTINE
*   REG 2 = USAGE NOT DEFINED
*   REG 3 = ADDRESS OF THE CVT
*   REG 4 = ADDRESS OF THE CURRENT TCB
*   REG 5 = ADDRESS OF THE CURRENT RB
*   REG 6 = USAGE NOT DEFINED
*   REG 7 = USAGE NOT DEFINED
*   REG 8 = USAGE NOT DEFINED
*   REG 9 = USAGE NOT DEFINED
*   REG 10 = USAGE NOT DEFINED
*   REG 11 = USAGE NOT DEFINED
*   REG 12 = BASE REGISTER FOR PROGRAM CHECK FLIH
*   REG 13 = USAGE NOT DEFINED
*   REG 14 = USAGE NOT DEFINED
*   REG 15 = POINTER TO BRABEND ROUTINE
*
         ORG   FIRST4K+((*-FIRST4K+31)/32*32)
MRCYEXIT DS    0D
         SVC   3                  PROVISION FOR THE SVC 3 "MERCY" EXIT
PCHKFLIH DS    0H
*
* MOVE CURRENT TIMER VALUE TO LOW STORAGE AREA.
*
         MVC   LOWTIME(4),X'50'   COPY TIMER VALUE TO SAFE LOCATION
*
* NOW WE WILL SAVE THE USER'S REGISTERS SO THAT WE CAN DO SOME WORK.
*
         STM   R0,R15,TYP3SAVE    STORE USER REGISTERS FOR LATER USE
*
* FIRST WE MUST ENSURE THAT THE ABEND OCCURRED FROM WITHIN THE TASK
* MODE. IF NOT, THEN THIS MAY BE A LOGIC ERROR AND WE SHOULD ABEND WITH
* A DUMP.
*
         CLI   LEVELFLG,C'T'      ABEND SHOULD HAVE BEEN AT TASK LEVEL
         BNE   LEVELABN           IF NOT, ABEND WITH A DUMP
         MVI   LEVELFLG,C'S'      OTHERWISE, SET LEVEL TO 'SYSTEM'
*
* SIMILARLY, IF THE ABEND OCCURRED WHILE IN THE SUPERVISOR STATE, WE
* HAVE A SERIOUS PROBLEM AND SHOULD NOT CONTINUE...
*
         TM    OLDTYPE3+1,X'01'   ABEND SHOULD HAVE BEEN IN PROB STATE
         BZ    LEVELABN           IF NOT, ABEND WITH A DUMP
*
* ESTABLISH ADDRESSABILITY INTO THIS MODULE.
*
         BALR  R12,R0             ESTABLISH A BASE REGISTER
         USING *,R12
*
* WE WILL NOW OBTAIN THE "STANDARD" REGISTER VALUE FOR THE INTERRUPT
* HANDLER. THESE ARE DEFINED AS FOLLOWS:
*
*  REG 3 = ADDRESS OF THE CVT (OBTAINED FROM BACKUP COPY AT X'4C')
*  REG 4 = ADDRESS OF THE CURRENT TCB
*  REG 5 = ADDRESS OF THE CURRENT RB
*
* ONCE WE HAVE THESE VALUES, WE CAN ALSO SET UP ADDRESSIBILITY INTO
* OUR DSECTS.
*
         L     R3,X'4C'           GET @ OF THE CVT
         L     R4,0(,R3)          GET @ OF TCB WORDS
         L     R4,4(,R4)          GET @ OF THE CURRENT TCB
         L     R5,0(,R4)          GET @ OF THE CURRENT RB
         USING CVT,R3             ESTABLISH ADDRESSIBILITY INTO CVT
         USING TCB,R4             ESTABLISH ADDRESSIBILITY INTO TCB
         USING RB,R5              ESTABLISH ADDRESSIBILITY INTO RB
*
* IF REG 5 CONTAINS ZERO THEN IT DOES NOT POINT TO A VALID RB, AND
* WE WILL ABEND ACCORDINGLY WITH A DUMP.
*
         LTR   R5,R5              IS THE REQUEST BLOCK @ INVALID?
         BZ    PCHKERR            IF SO THEN ABEND WITH A DUMP
*
* NOW WE WILL SAVE THE USER'S REGISTERS IN THE TCB SAVE AREAS ALLOTTED.
*
         MVC   TCBGRS(16*4),TYP3SAVE
         STD   0,TCBFRS           STORE THE FOATING POINT REGISTERS
         STD   2,TCBFRS+1*8
         STD   4,TCBFRS+2*8
         STD   6,TCBFRS+3*8
*
* WE WILL ALSO STORE THE USER'S PSW INTO THE RB SO THAT THE TCB
* MAY LATER BE RE-DISPATCHED.
*
         MVC   RBOPSW(8),OLDTYPE3 STORE OLD PSW IN REQUEST BLOCK
*
* NOW WE WILL COMPUTE A VALUE TO BE ADDED TO TCBTCPU. THIS IS THE
* TOTAL CPU TIME ELAPSED BETWEEN DISPATCH OF THE RB AND THIS SVC.
*
         L     R8,TCBTDISP        GET CPU TIME AT DISPATCH
         S     R8,LOWTIME         SUBTRACT CPU TIME AT SVC INTERRUPT
         TM    OLDTYPE3+1,X'01'   WAS INTERRUPT IN SUPERVISOR STATE?
         BZ    ADDSTM3            IF SO THEN ADD TIME TO SUP. TOTAL
*
         A     R8,TCBTCPUP        ADD ELAPSED CPU TIME TO TCB TOTAL
         ST    R8,TCBTCPUP        AND STORE IT BACK INTO THE TCB FIELD
         B     CHKPIE             BRANCH TO I/O PROCESSING CODE
*
ADDSTM3  DS    0H
         A     R8,TCBTCPUS        ADD ELAPSED CPU TIME TO TCB TOTAL
         ST    R8,TCBTCPUS        AND STORE IT BACK INTO THE TCB FIELD
*
* NOW WE MUST CHECK IF A SPIE ENVIRONMENT EXISTS. IF SO THEN WE WILL
* TRANSFER CONTROL TO THE PROPER EXIT ROUTINE, OR TO THE ABEND
* ROUTINE IF THE INTERRUPT TYPE IS NOT TO-BE-PROCESSED.
*
CHKPIE   DS    0H
         L     R7,TCBPIE          GET ADDRESS OF SPIE CTL AREA
         LTR   R7,R7              IS THERE ACTUALLY AN SCA DEFINED?
         BZ    PCHKABND           IF NOT THEN CAUSE PGM ABEND
*
* THIS IS WHERE WE GO IF THERE IS CURRENTLY A SPIE ENVIRONMENT. WE
* MUST TEST TO SEE IF THE INTERUPTS-TO-PROCESS BITS IN THE USER PICA
* MATCH THE ONE THAT HAS OCCURRED IN THE USER'S PROGRAM. IF SO THEN
* WE WILL GIVE CONTROL TO THE USER'S SPIE EXIT. OTHERWISE, WE WILL
* IGNORE THE SPIE EXIT AND FORCE AN ABEND OF THE USER'S PROGRAM.
*
         TM    TCBPIE,X'80'       IS THE TCB BUSY BIT ON?
         BNZ   PCHKABND           IF SO THEN INT. WAS IN EXIT RTN
*                                 AND WE WILL ABEND THE USER PROGRAM
         L     R8,0(,R7)          GET ADDRESS OF THE USER'S PIE
         TM    0(R8),X'80'        IS THE PIE BUSY BIT ON?
         BNZ   PCHKABND           IF SO THEN INT. WAS IN EXIT RTN
*                                 AND WE WILL ABEND THE USER PROGRAM
         L     R9,0(,R8)          GET ADDRESS OF THE USER'S PICA
         LTR   R9,R9              IS THE PICA ADDRESS ZERO?
         BZ    PCHKABND           IF SO THEN TREAT AS NORMAL PGM CHK
*                                 AND WE WILL ABEND THE USER PROGRAM
         L     R10,0(,R9)         GET ADDRESS OF THE EXIT ROUTINE
         LTR   R9,R9              IS THE EXIT ADDRESS ZERO?
         BZ    PCHKABND           IF SO THEN TREAT AS NORMAL PGM CHK
*
         LH    R10,OLDTYPE3+2     GET INTERRUPT TYPE FROM OLD PSW
         L     R11,TYPECODE       FIND BIT POSITION FOR INT. TYPE
         SRL   R11,0(R10)
         LH    R10,4(,R9)         GET INTERRUPTS-TO-PROCESS BITS
*
         NR    R10,R11            TEST IF INTERRUPT TYPES MATCH
         BZ    PCHKABND           IF NOT THEN TYPE IS NOT SUPPORTED
*                                 AND WE WILL ABEND THE USER PROGRAM
*
* AT THIS POINT WE HAVE DETERMINED THAT THE SPIE EXIT ROUTINE IS
* TO HANDLE THIS PROGRAM INTERRUPT. WE WILL SET THINGS UP ACCORDINGLY.
*
         MVC   4(8,R8),RBOPSW     MOVE PGM PSW TO PIE
         MVC   12(8,R8),TCBGRS+14*4  MOVE REGS 14 & 15 FROM TCB TO PIE
         MVC   20(12,R8),TCBGRS      MOVE REGS 0 - 2 FROM TCB TO PIE
*
         MVC   RBOPSW+5(3),1(R9)  SET UP ADDRESS OF EXIT RTN
         MVC   TCBGRS+15*4(4),0(R9)  POINT REG 15 TO START OF EXIT RTN
*
         MVC   TCBGRS+14*4(4),EXITEXIT
         ST    R8,TCBGRS+1*4
*
         MVC   TCBGRS(4),SPIEREG0
         MVC   TCBGRS+2*4(4),SPIEREG2
*
         OI    TCBPIE,X'80'       TURN ON BUSY BIT IN TCB PIE
         OI    0(R8),X'80'        TURN ON BACKUP BUSY BIT IN PIE ITSELF
*
         L     R6,CVT0DS          OBTAIN ADDRESS OF CHAP
         BR    R6                 DISPATCH THE USER'S EXIT ROUTINE
*
* WE COME HERE WHEN THERE IS NO SPIE ENVIRONMENT. THE PROGRAM
* INTERRUPT WILL RESULT IN THE TERMINATION OF THE USER'S PROGRAM.
*
PCHKABND DS    0H
         LH    R1,OLDTYPE3+2      GET INTERRUPTION CODE FROM OLD PSW
         SLL   R1,12              SHIFT CODE IN INTO SYSTEM CODE POS
         O     R1,DUMPCODE        SET HIGH BIT TO CAUSE SVC 13 DUMP
*
         L     R15,CVTBRABN       GET ADDRESS OF THE BRABEND ROUTINE
         BR    R15                BRANCH TO BRABEND ROUTINE
*
* THIS IS WHERE WE GO IF THERE IS NO RB POINTED TO BY REG 5.
*
PCHKERR  DS    0H
         XOPC  25                 ABEND WITH A DUMP
         DC    C'THERE IS NO RB FOR THE CURRENT TCB'
*
DUMPCODE DC    0F'0',X'800C0000'  DUMP CODE FOR SVC 13
TYPECODE DC    0F'0',X'00008000'
EXITEXIT DC    A(MRCYEXIT)
SPIEREG0 DC    CL4'REG0'
SPIEREG2 DC    CL4'REG2'
         DROP  R12
         EJECT
*
*       >     RRRR   QQQ  EEEEE   EEEEE N   N  QQQ      <
*        >    R   R Q   Q E       E     NN  N Q   Q    <
*         >   RRRR  Q Q Q EEEE    EEEE  N N N Q Q Q   <
*        >    R R   Q  QQ E       E     N  NN Q  QQ    <
*       >     R  R   QQQQ EEEEE   EEEEE N   N  QQQQ     <
*
*
* THE FOLLOWING CODE WILL ADD AN RQE TO THE CHAIN OF RQE'S HANGING
* THE GIVEN UCB.
*
*   REG 1 = ADDRESS OF IOB FOR THE REQUESTED I/O OPERATION
*   REG 3 = ADDRESS OF THE CVT
*   REG 4 = ADDRESS OF THE CURRENT TCB
*   REG 5 = ADDRESS OF THE CURRENT RB
*   REG 6 = STARTING ADDRESS OF THIS ROUTINE
*
* THE COMPLETE REGISTER USAGE OF THIS ROUTINE IS AS FOLLOWS:
*
*   REG 1 = POINTER TO I/O CONTROL BLOCK PASSED BY USER
*   REG 2 = USAGE NOT DEFINED
*   REG 3 = ADDRESS OF THE CVT
*   REG 4 = ADDRESS OF THE CURRENT TCB
*   REG 5 = ADDRESS OF THE CURRENT RB
*   REG 6 = BASE REGISTER
*   REG 7 = POINTER TO THE CURRENT UCB
*   REG 8 = WORK REGISTER
*   REG 9 = WORK REGISTER
*   REG 10 = POINTER TO THE NEW RQE BEING CREATED
*   REG 11 = WORK REGISTER
*   REG 12 = USAGE NOT DEFINED
*   REG 13 = USAGE NOT DEFINED
*   REG 14 = USAGE NOT DEFINED
*   REG 15 = USAGE NOT DEFINED
*
         ORG   FIRST4K+X'4000'
RQEENQ   DS    0D
*
* ESTABLISH ADDRESSIBILITY INTO THE VARIOUS CONTROL BLOCKS, AS WELL
* AS INTO THIS ROUTINE.
*
         USING RQEENQ,R6          USE REG 6 AS OUR BASE REGISTER
*
         USING IOB,R1             ESTABLISH ADDRESSIBILITY INTO I/O BLK
         USING CVT,R3             ESTABLISH ADDRESSIBILITY INTO CVT
         USING TCB,R4             ESTABLISH ADDRESSIBILITY INTO TCB
         USING RB,R5              ESTABLISH ADDRESSIBILITY INTO RB
*
* HERE, WE WILL TEST AN SET TO ZERO THE TYPE 1 FLAG. THIS IS TO ACCOUNT
* FOR THE FACT THAT WE WILL NOT BE RETURNING TO THE SVC-FLIH, WHICH
*
         CLI   TYP1FLAG,C'1'      CHECK SVC TYPE FLAG
         BNE   BADTYPE            IF ALREADY SET THEN THERE IS AN ERROR
         MVI   TYP1FLAG,C'0'      OTHERWISE, SET TYPE 1 FLAG TO 'YES'
*
* THIS IS WHERE WE ATTEMPT TO FIND THE UCB FOR THE DEVICE WITH THE
* SAME ADDRESS GIVEN IN THE IOB. THE RQE WILL THEN BE ADDED TO THE
* RQE CHAIN WHICH HANGS FROM THIS UCB.
*
         L     R7,CVTUCBS         GET ADDRESS OF FIRST UCB IN CHAIN
         USING UCB,R7             SET UP ADDRESSABILITY INTO THE UCB
         XR    R8,R8              CLEAR OUT A WORK REGISTER
UCBLOOP  DS    0H
         LTR   R7,R7              DID WE HIT THE END OF THE CHAIN?
         BZ    NODEVICE           IF SO THEN BAD DEVICE ADDRESS
*
         LH    R8,UCBCHAN         GET DEVICE ADDRESS OF THIS UNIT
         CH    R8,IOBDEVAD        DOES IT MATCH THE ADDRESS IN IOB?
         BE    DEVICEOK           IF SO THEN PROCESS THE RQE
*
         L     R7,UCBUCB          OTHERWISE, POINT TO NEXT UCB
         B     UCBLOOP
*
* NOW WE WILL INTIALIZE AN RQE TO BE ADDED TO THE RQE CHAIN.
*
DEVICEOK DS    0H
         GETCB100
         XC    0(RQELNTH,R10),0(R10) SET ENTIRE REQ. BLK TO ZEROS
         USING RQE,R10               SET UP ADDRESSABILITY INTO THE RQE
*
         MVC   RQEIDENT(4),RQEDOC MOVE IN RQE IDENTIFIER STRING
         ST    R1,RQEIOB          STORE ADDRESS OF IOB
         ST    R7,RQEUCB          STORE ADDRESS OF UCB FOR THIS DEVICE
         ST    R4,RQETCB          STORE ADDRESS OF USER'S TCB
         ST    R5,RQERB           STORE ADDRESS OF THE CURRENT RB
         DROP R10
*
* THIS IS WHERE WE ACTUALLY ADD THE RQE TO THE RQE CHAIN. IN ORDER TO
* DETERMINE WHERE TO PUT IT, WE MUST RUN THE RQE CHAIN IN SEARCH OF
* THE LAST RQE THAT WAS ADDED; THIS ONE WILL GO JUST BELOW IT.
*
         L     R8,UCBWARQE        GET ADDRESS OF FIRST RQE IN CHAIN
         USING RQE,R8              SET UP ADDRESSABILITY INTO THE RQE
*
         LTR   R8,R8              IS THE RQE CHAIN EMPTY?
         BNZ   NEXTRQE            IF NOT THEN RUN THE RQE CHAIN
*
         ST    R10,UCBWARQE       OTHERWISE, HANG THE NEW RQE
*                                 DIRECTLY UNDER THE UCB
         B     FIXRB              CONTINUE PROCESSING
*
NEXTRQE  DS    0H
         LR    R9,R8              SET REG 7 ==> @ OF PREVIOUS RQE
         L     R8,RQENRQE         GET ADDRESS OF NEXT RQE IN CHAIN
*
         LTR   R8,R8              HAVE WE RUN THE ENTIRE RQE CHAIN?
         BNZ   NEXTRQE            IF NOT THEN KEEP RUNNING...
*
         LR    R8,R9              OTHERWISE, BACK UP TO PREVIOUS RQE
         ST    R10,RQENRQE        STORE ADDRESS OF "NEW" FINAL RQE
*
* NEXT, WE WILL MAKE THE CURRENT TASK NON-DISPATCHABLE BY INCREMENTING
* THE RB WAIT COUNT FIELD. THE TASK WILL NOT BE RE-DISPATCHABLE UNTIL
* THE I/O OPERATION HAS COMPLETED, AND THE I/O FLIH IS INVOKED, OR THE
* START I/O ROUTINE DETECTS AN END-OF-FILE CONDITION.
*
FIXRB    DS    0H
         XR    R11,R11            CLEAR OUT A WORK REGISTER
         IC    R11,RBWCF          GET CURRENT RB WAIT COUNT
         LA    R11,1(,R11)        INCREMENT RB WAIT COUNT BY 1
         STC   R11,RBWCF          STORE THE NEW RB WAIT COUNT
*
* FINALLY, WE ARE READY TO BRANCH TO THE BEGINIO ROUTINE, WHICH WILL
* ACTUALLY START THE I/O PROCESS.
*
EDITBIO  DS    0H
         L     R6,CVTBGNIO        GET ADDRESS OF BEGIN I/O ROUTINE
         BR    R6                 BRANCH TO THE BEGIN I/O CODE
*
* THIS ERROR ROUTINE RECEIVES CONTROL WHEN THE INTERRUPT TYPE FLAG
* CONTAINS AN INVALID VALUE. THIS COULD BE INDICATIVE OF A LOGIC
* ERROR WITHIN THE OPERATING SYSTEM.
*
BADTYPE  DS    0H
         XOPC  25                 ABEND WITH A DUMP
         DC    C'SVC TYPE FLAG INVALID'
*
* THIS SECTION OF CODE IS INVOKED WHEN THE DEVICE ADDRESS GIVEN IN THE
* IOB IS INVALID (I.E. DOES NOT MATCH THE DEVICE ADDRESS IN ANY OF THE
* UCBS IN THE UCB CHAIN).
*
NODEVICE DS    0H
         XOPC 25
         DC    C'INVALID DEVICE ADDRESS IN IOB'
*
RQEDOC   DC    CL4'RQE '          DOCUMENTATION
*
         DROP R1,R3,R4,R5,R6,R7,R8
         EJECT
*
*  >     BBBB  EEEEE GGGGG IIIII N   N     IIIII     / OOOOO     <
*   >    B   B E     G       I   NN  N       I      /  O   O    <
*    >   BBBB  EEEE  G GGG   I   N N N       I     /   O   O   <
*   >    B   B E     G   G   I   N  NN       I    /    O   O    <
*  >     BBBB  EEEEE GGGGG IIIII N   N     IIIII /     OOOOO     <
*
*
* THE FOLLOWING COMPRISED THE BEGIN I/O ROUTINE. IT SCANS THE UCB
* CHAIN, LOOKING FOR A NON-BUSY DEVICE WITH RQE'S PENDING. THIS
* MODULE IS, THUS, A DISPATCHER FOR I/O OPERATIONS.
*
*   REG 3 = ADDRESS OF THE CVT
*   REG 4 = ADDRESS OF THE CURRENT TCB
*   REG 5 = ADDRESS OF THE CURRENT RB
*   REG 6 = STARTING ADDRESS OF THIS ROUTINE
*
* THE COMPLETE REGISTER USAGE OF THIS ROUTINE IS AS FOLLOWS:
*
*   REG 1 = USAGE NOT DEFINED
*   REG 2 = USAGE NOT DEFINED
*   REG 3 = ADDRESS OF THE CVT
*   REG 4 = ADDRESS OF THE CURRENT TCB
*   REG 5 = ADDRESS OF THE CURRENT RB
*   REG 6 = BASE REGISTER
*   REG 7 = USAGE NOT DEFINED
*   REG 8 = USAGE NOT DEFINED
*   REG 9 = USAGE NOT DEFINED
*   REG 10 = USAGE NOT DEFINED
*   REG 11 = USAGE NOT DEFINED
*   REG 12 = USAGE NOT DEFINED
*   REG 13 = USAGE NOT DEFINED
*   REG 14 = USAGE NOT DEFINED
*   REG 15 = USAGE NOT DEFINED
*
BEGINIO  DS    0D
*
* ESTABLISH ADDRESSIBILITY INTO THE VARIOUS CONTROL BLOCKS, AS WELL
* AS INTO THIS ROUTINE.
*
         USING BEGINIO,R6         USE REG 6 AS OUR BASE REGISTER
*
         USING CVT,R3             ESTABLISH ADDRESSIBILITY INTO CVT
         USING TCB,R4             ESTABLISH ADDRESSIBILITY INTO TCB
         USING RB,R5              ESTABLISH ADDRESSIBILITY INTO RB
*
* NOW WE WILL ATTEMPT TO FIND A UCB IN THE UCB CHAIN THAT:
*
*         (1) IS NOT BUSY, AND
*         (2) HAS AT LEAST ONE RQE CHAINED FROM IT.
*
* WHEN WE FIND A UCB MEETING THESE TWO CIRTERIA, WE WILL BEGIN THE
* I/O OPERATION REPRESENTED BY THAT UCB/RQE.
*
RUNUCBS  DS    0H
         L     R7,CVTUCBS         GET ADDRESS OF FIRST UCB IN CHAIN
         USING UCB,R7             SET UP ADDRESSABILITY INTO THE UCB
         XR    R8,R8              CLEAR OUT A WORK REGISTER
*
TESTDEVC DS    0H
         LTR   R7,R7              DID WE HIT THE END OF THE CHAIN?
         BZ    NOMOREIO           IF SO, THERE ARE NO I/O'S TO START
*
         CLI   UCBFLA,X'FF'       IS THE DEVICE BUSY?
         BE    TRYNEXT            IF SO THEN WE CAN'T START ANOTHER I/O
         L     R12,UCBWARQE       GET ADDRESS OF FIRST RQE IN CHAIN
         LTR   R12,R12            IS THERE AN RQE PENDING?
         BNZ   DOIO               IF SO THEN BRANCH TO START I/O CODE
*
TRYNEXT  DS    0H
         L     R7,UCBUCB          ATTEMPT TO START I/O FOR NEXT UCB
         B     TESTDEVC
*
* AT THIS POINT, WE HAVE ISOLATED A NON-BUSY DEVICE WITH AN RQE THAT
* IS PENDING. WE WILL NOW ATTEMPT TO START THE I/O OPERATION
* REPRESENTED BY THAT UCB/RQE.
*
DOIO     DS    0H
         L     R8,UCBWARQE        GET ADDRESS OF THE NEW CURRENT RQE
         USING RQE,R8             ESTABLISH ADDRESSABILITY INTO RQE
*
         L     R4,RQETCB          GET ADDRESS OF TCB FOR THIS RQE
         L     R5,RQERB           GET ADDRESS OF RB FOR THIS RQE
*
         L     R10,UCBIOSTR       GET @ OF THE START I/O RTN FOR DEVICE
         BALR  R14,R10            BRANCH TO THE START I/O RTN
         ST    R15,TCBGRS+15*4    STORE I/O RETURN CODE FOR USER
*
         B     RUNUCBS            RUN THE UCB CHAIN AGAIN FROM THE TOP
*
* HAVING DISPATCHED ALL PENDING I/O'S ON NON-BUSY DEVICES, WE CAN NOW
* BRANCH BACK TO PROGRAM DISPATCHER.
*
NOMOREIO DS    0H
         L     R6,CVTCHAP         GET ADDRESS OF CHAP
         BR    R6                 BRANCH TO CHAP
         DROP R3,R4,R5,R6,R8
         EJECT
******
*
* SSSSS TTTTT   A   RRRR  TTTTT     IIIII     / OOOOO     ""  CCCCC  ""
* S       T    A A  R   R   T         I      /  O   O         C
* SSSSS   T   A   A RRRR    T         I     /   O   O         C
*     S   T   AAAAA R R     T         I    /    O   O         C
* SSSSS   T   A   A R  R    T       IIIII /     OOOOO         CCCCC
*
*
* THIS IS THE START I/O FOR VIRTUAL READER 1, WHOSE DEVICE ADDRESS IS
* X'000C'. UPON ENTRY TO THIS ROUTINE THE FOLLOWING REGISTERS VALUES
* MUST APPLY:
*
*      REG 3 ==> ADDRESS OF THE CVT
*      REG 4 ==> ADDRESS OF THE TCB REQUESTING THE I/O
*      REG 5 ==> ADDRESS OF THE RB FOR THE TCB ABOVE
*      REG 7 ==> ADDRESS OF THE UCB ASSOCIATED WITH THIS DEVICE
*      REG 10 ==> ENTRY ADDRESS OF THE SIO ROUTINE
*      REG 12 ==> POINTER TO THE RQE REQUESTING THE I/O OPERATION
*      REG 14 ==> RETURN ADDRESS FROM THE SIO ROUTINE
*
******
SIO000C  DS    0D
         USING SIO000C,R10        SET UP ADDRESSABILITY
*
         B     GO000C             BRANCH AROUND CCW @
         DC    A(CCW000C+8)       ADDRESS OF END OF CHANNEL PROGRAM
GO000C   DS    0H
*
         USING CVT,R3
         USING TCB,R4
         USING RB,R5
         USING UCB,R7
         USING RQE,R12
*
         STM   R0,R15,SIOCSAVE    SAVE REGISTERS UPON ENTRY
*
* FIRST, WE WILL MODIFY THE CCW TO REFLECT THE PARTICULAR I/O OPERATION
* ABOUT TO BE PERFORMED. THE INFORMATION THAT ENABLES US TO DO THIS IS
* LOCATED WITHIN THE IOB.
*
         L     R1,RQEIOB          GET ADDRESS OF THE ASSOCIATED IOB
         USING IOB,R1             SET UP ADDRESSABILITY INTO IOB
*
         MVC   CCW000C+1(3),IOBUFADD+1 MOVE BUFFER ADDRESS INTO THE CCW
         MVC   CCW000C+6(2),IOBUFLEN   MOVE BUFFER LENGTH INTO THE CCW
*
* NOW WE CAN STORE THE CORRECT CHANNEL ADDRESS WORD, AND ISSUE THE
* START I/O COMMAND.
*
         LA    R11,CCW000C        GET ADDRESS OF THE CCW
         ST    R11,X'48'          STORE THE ADDRESS IN THE CAW AREA
         SIO   X'00C'             START THE I/O OPERATION
*
* NOW, WE WILL ACT ACCORDING TO THE CC SET BY THE SIO COMMAND.
*
         BC    4,TESTEOF          ON CC=1 TEST FOR END-OF-FILE
         BC    2,BUSY000C         ON CC=2 CHANNEL IS BUSY (BAD!)
         BC    1,NOP000C          ON CC=3 DEVICE NOT OPERATIONAL
*
* AT THIS POINT, WE HAVE HAD A SUCCESSFUL START OF THE I/O OPERATION.
* WE MUST NOW MARK THE UCB AS BUSY, AFTER RECORDING THE NEW I/O COUNT
* IN THE TCB.
*
         MVC   TCBTSSIO(4),X'50'  STORE TIME THAT I/O STARTED
         L     R8,TCBTSLIC+4      GET TOTAL NUMBER OF I/O FOR TASK
         LA    R8,1(,R8)          INCREMENT TOTAL BY ONE
         ST    R8,TCBTSLIC+4      STORE NEW TOTAL
*
         L     R8,TCBTSLIC+8      GET TOTAL NUMBER OF I/O FOR DEVICE
         LA    R8,1(,R8)          INCREMENT TOTAL BY ONE
         ST    R8,TCBTSLIC+8      STORE NEW TOTAL
*
         ST    R12,UCBCURQE       STORE @ OF RQE AS THE CURRENT ONE
         MVI   UCBFLA,X'FF'       MARK THE UCB AS BUSY
         SR    R15,R15            SEND BACK A RETURN CODE OF 0
*
* NOW WE ARE READY TO BRANCH BACK TO THE CALLER, WITH A RETURN CODE
* IN REGISTER 15.
*
RCODE    DS    0H
         LM    R0,R14,SIOCSAVE    RESTORE CALLING ROUTINE'S REG VALUES
         BR    R14                BRANCH BACK TO BEGIN I/O
*
* HERE, WE WILL TEST THE CSW FOR AN END-OF-FILE CONDITION. IF EOF WAS
* ==> NOT <== HIT, THEN WE HAD SOME OTHER KIND OF ERROR AND WE SHOULD
* ABEND WITH A DUMP.
*
TESTEOF  DS    0H
         TM    X'44',X'80'+UE     TEST FOR UNIT EXCP. AND/OR ATTENTION
         BZ    CSW000C            IF NOT EOF THEN ABEND WITH A DUMP
*
* AT THIS POINT, WE HAVE DETERMINED THAT AN EOF CONDITION EXISTS. WE
* MUST NOW HANDLE THAT INFORMATION APPROPRIATELY.
*
         POPRQE CBREG=R12
         XC    UCBCURQE(4),UCBCURQE THERE IS NO CURRENT RQE
         FRECB100 CBREG=R12
*
         XR    R13,R13
         IC    R13,RBWCF          GET RB WAIT COUNT
         BCTR  R13,R0             DECREMENT WAIT COUNT BY ONE
         STC   R13,RBWCF          STORE THE NEW RB WAIT COUNT
*
         LA    R15,4              SEND BACK A RETURN CODE OF 4
         B     RCODE              BRANCH BACK TO BEGIN I/O
*
* CONTROL COMES TO THIS SECTION OF CODE ONLY WHEN THE CHANNEL IS BUSY.
*
BUSY000C DS    0H
         XOPC  25
         DC    C'CHANNEL X''000C'' IS BUSY'
*
* THIS CODE IS EXECUTED WHEN WE GET A CC OF 1 FROM SIO (CSW STORED).
*
CSW000C  DS    0H
         XOPC  25
         DC    C'CSW FOR X''000C'' HAS BEEN STORED'
*
* THIS CODE IS EXECUTED WHEN WE GET A CC OF 3 FROM SIO (DEVICE
* IS NOT OPERATIONAL).
*
NOP000C  DS    0H
         XOPC  25
         DC    C'DEVICE ON CHANNEL ''000C'' IS NOT OPERATIONAL'
*
SIOCSAVE DC    16F'-1'            SAVE AREA FOR CALLING RTN'S REGISTERS
CCW000C  CCW 2,0,0,0
*
*
         EJECT
******
*
* SSSSS TTTTT   A   RRRR  TTTTT     IIIII     / OOOOO     ""  DDDD   ""
* S       T    A A  R   R   T         I      /  O   O         D   D
* SSSSS   T   A   A RRRR    T         I     /   O   O         D   D
*     S   T   AAAAA R R     T         I    /    O   O         D   D
* SSSSS   T   A   A R  R    T       IIIII /     OOOOO         DDDD
*
*
* THIS IS THE START I/O FOR VIRTUAL READER 2, WHOSE DEVICE ADDRESS IS
* X'000D'. UPON ENTRY TO THIS ROUTINE THE FOLLOWING REGISTERS VALUES
* MUST APPLY:
*
*      REG 3 ==> ADDRESS OF THE CVT
*      REG 4 ==> ADDRESS OF THE TCB REQUESTING THE I/O
*      REG 5 ==> ADDRESS OF THE RB FOR THE TCB ABOVE
*      REG 7 ==> ADDRESS OF THE UCB ASSOCIATED WITH THIS DEVICE
*      REG 10 ==> ENTRY ADDRESS OF THE SIO ROUTINE
*      REG 12 ==> POINTER TO THE RQE REQUESTING THE I/O OPERATION
*      REG 14 ==> RETURN ADDRESS FROM THE SIO ROUTINE
*
******
SIO000D  DS    0D
         USING SIO000D,R10        SET UP ADDRESSABILITY
*
         B     GO000D             BRANCH AROUND CCW @
         DC    A(CCW000D+8)       ADDRESS OF END OF CHANNEL PROGRAM
GO000D   DS    0H
*
         USING CVT,R3
         USING TCB,R4
         USING RB,R5
         USING UCB,R7
         USING RQE,R12
*
         STM   R0,R15,SIODSAVE    SAVE REGISTERS UPON ENTRY
*
* FIRST, WE WILL MODIFY THE CCW TO REFLECT THE PARTICULAR I/O OPERATION
* ABOUT TO BE PERFORMED. THE INFORMATION THAT ENABLES US TO DO THIS IS
* LOCATED WITHIN THE IOB.
*
         L     R1,RQEIOB          GET ADDRESS OF THE ASSOCIATED IOB
         USING IOB,R1             SET UP ADDRESSABILITY INTO IOB
*
         MVC   CCW000D+1(3),IOBUFADD+1 MOVE BUFFER ADDRESS INTO THE CCW
         MVC   CCW000D+6(2),IOBUFLEN   MOVE BUFFER LENGTH INTO THE CCW
*
* NOW WE CAN STORE THE CORRECT CHANNEL ADDRESS WORD, AND ISSUE THE
* START I/O COMMAND.
*
         LA    R11,CCW000D        GET ADDRESS OF THE CCW
         ST    R11,X'48'          STORE THE ADDRESS IN THE CAW AREA
         SIO   X'00D'             START THE I/O OPERATION
*
* NOW, WE WILL ACT ACCORDING TO THE CC SET BY THE SIO COMMAND.
*
         BC    4,TESTEOFD         ON CC=1 TEST FOR END-OF-FILE
         BC    2,BUSY000D         ON CC=2 CHANNEL IS BUSY (BAD!)
         BC    1,NOP000D          ON CC=3 DEVICE NOT OPERATIONAL
*
* AT THIS POINT, WE HAVE HAD A SUCCESSFUL START OF THE I/O OPERATION.
* WE MUST NOW MARK THE UCB AS BUSY.
*
         MVC   TCBTSSIO(4),X'50'  STORE TIME THAT I/O STARTED
         L     R8,TCBTSLIC+4      GET TOTAL NUMBER OF I/O FOR TASK
         LA    R8,1(,R8)          INCREMENT TOTAL BY ONE
         ST    R8,TCBTSLIC+4      STORE NEW TOTAL
*
         L     R8,TCBTSLIC+12     GET TOTAL NUMBER OF I/O FOR DEVICE
         LA    R8,1(,R8)          INCREMENT TOTAL BY ONE
         ST    R8,TCBTSLIC+12     STORE NEW TOTAL
*
         ST    R12,UCBCURQE       STORE @ OF RQE AS THE CURRENT ONE
         MVI   UCBFLA,X'FF'       MARK THE UCB AS BUSY
         SR    R15,R15            SEND BACK A RETURN CODE OF 0
*
* NOW WE ARE READY TO BRANCH BACK TO THE CALLER, WITH A RETURN CODE
* IN REGISTER 15.
*
RCODED   DS    0H
         LM    R0,R14,SIODSAVE    RESTORE CALLING ROUTINE'S REG VALUES
         BR    R14                BRANCH BACK TO BEGIN I/O
*
* HERE, WE WILL TEST THE CSW FOR AN END-OF-FILE CONDITION. IF EOF WAS
* ==> NOT <== HIT, THEN WE HAD SOME OTHER KIND OF ERROR AND WE SHOULD
* ABEND WITH A DUMP.
*
TESTEOFD DS    0H
         TM    X'44',X'80'+UE     TEST FOR UNIT EXCP. AND/OR ATTENTION
         BZ    CSW000D            IF NOT EOF THEN ABEND WITH A DUMP
*
* AT THIS POINT, WE HAVE DETERMINED THAT AN EOF CONDITION EXISTS. WE
* MUST NOW HANDLE THAT INFORMATION APPROPRIATELY.
*
         POPRQE CBREG=R12
         XC    UCBCURQE(4),UCBCURQE THERE IS NO CURRENT RQE
         FRECB100 CBREG=R12
*
         XR    R13,R13
         IC    R13,RBWCF          GET RB WAIT COUNT
         BCTR  R13,R0             DECREMENT WAIT COUNT BY ONE
         STC   R13,RBWCF          STORE THE NEW RB WAIT COUNT
*
         LA    R15,4              SEND BACK A RETURN CODE OF 4
         B     RCODED             BRANCH BACK TO BEGIN I/O
*
* CONTROL COMES TO THIS SECTION OF CODE ONLY WHEN THE CHANNEL IS BUSY.
*
BUSY000D DS    0H
         XOPC  25
         DC    C'CHANNEL X''000D'' IS BUSY'
*
* THIS CODE IS EXECUTED WHEN WE GET A CC OF 1 FROM SIO (CSW STORED).
*
CSW000D  DS    0H
         XOPC  25
         DC    C'CSW FOR X''000D'' HAS BEEN STORED'
*
* THIS CODE IS EXECUTED WHEN WE GET A CC OF 3 FROM SIO (DEVICE
* IS NOT OPERATIONAL).
*
NOP000D  DS    0H
         XOPC  25
         DC    C'DEVICE ON CHANNEL ''000D'' IS NOT OPERATIONAL'
*
SIODSAVE DC    16F'-1'            SAVE AREA FOR CALLING RTN'S REGISTERS
CCW000D  CCW 2,0,0,0
*
*
         EJECT
******
*
* SSSSS TTTTT   A   RRRR  TTTTT     IIIII     / OOOOO     ""  EEEEE  ""
* S       T    A A  R   R   T         I      /  O   O         E
* SSSSS   T   A   A RRRR    T         I     /   O   O         EEEE
*     S   T   AAAAA R R     T         I    /    O   O         E
* SSSSS   T   A   A R  R    T       IIIII /     OOOOO         EEEEE
*
*
* THIS IS THE START I/O FOR VIRTUAL PRINTER 1, WHOSE DEVICE ADDRESS IS
* X'000E'. UPON ENTRY TO THIS ROUTINE THE FOLLOWING REGISTERS VALUES
* MUST APPLY:
*
*      REG 3 ==> ADDRESS OF THE CVT
*      REG 4 ==> ADDRESS OF THE TCB REQUESTING THE I/O
*      REG 5 ==> ADDRESS OF THE RB FOR THE TCB ABOVE
*      REG 7 ==> ADDRESS OF THE UCB ASSOCIATED WITH THIS DEVICE
*      REG 10 ==> ENTRY ADDRESS OF THE SIO ROUTINE
*      REG 12 ==> POINTER TO THE RQE REQUESTING THE I/O OPERATION
*      REG 14 ==> RETURN ADDRESS FROM THE SIO ROUTINE
*
******
SIO000E  DS    0D
         USING SIO000E,R10        SET UP ADDRESSABILITY
*
         B     GO000E             BRANCH AROUND CCW @
         DC    A(CCW000E2+8)      ADDRESS OF END OF CHANNEL PROGRAM
GO000E   DS    0H
*
         USING CVT,R3
         USING TCB,R4
         USING RB,R5
         USING UCB,R7
         USING RQE,R12
*
         STM   R0,R15,SIOESAVE    SAVE REGISTERS UPON ENTRY
*
* FIRST, WE WILL MODIFY THE CCW TO REFLECT THE PARTICULAR I/O OPERATION
* ABOUT TO BE PERFORMED. THE INFORMATION THAT ENABLES US TO DO THIS IS
* LOCATED WITHIN THE IOB.
*
         L     R1,RQEIOB          GET ADDRESS OF THE ASSOCIATED IOB
         USING IOB,R1             SET UP ADDRESSABILITY INTO IOB
*
* THIS IS WHERE WE ACCOUNT FOR CARRIAGE CONTROL.
*
         L     R2,IOBUFADD        GET THE ACTUAL PRINT BUFFER ADDRESS
         LH    R11,IOBUFLEN       GET BUFFER LEN
         LA    R15,1(,R2)         R15 ==> FIRST CHARACTER TO BE PRINTED
         LA    R14,CCW000E2       BY DEFAULT, EXECUTE ONLY ONE CCW
*
         CLI   0(R2),C'+'         ARE WE TO SUPPRESS SPACING?
         BE    PRNT000E           IF SO THEN EXECUTE ONLY ONE CCW
*
* HERE, WE MUST TRANSLATE THE USER-SUPPLIED ANSI CARRIAGE CONTROL TO
* MACHINE CARRIAGE CONTROL.
*
         LA    R0,8               SINCE WE HAVE CARRIAGE CONTROL,
         SR    R14,R0             WE WILL EXECUTE A 2-CCW PRINT PROGRAM
         STCM  R2,7,CCW000E+1     MOVE BUFFER ADDR INTO THE CCW
*
         CLI   0(R2),C'0'         PERFORM DOUBLE SPACING?
         BNE   TRIP000E           IF NOT THE CHECK NEXT POSSIBILITY
         MVI   CCW000E,X'13'      OTHERWISE, SET PROPER MACHINE CONTROL
         B     PRNT000E           AND BRANCH TO REMAINING PRINT CODE
*
TRIP000E CLI   0(R2),C'-'         PERFORM TRIPLE SPACING?
         BNE   PAGE000E           IF NOT THE CHECK NEXT POSSIBILITY
         MVI   CCW000E,X'1B'      OTHERWISE, SET PROPER MACHINE CONTROL
         B     PRNT000E           AND BRANCH TO REMAINING PRINT CODE
*
PAGE000E CLI   0(R2),C'1'         ADVANCE TO NEXT PAGE?
         BNE   DEFAULTE           IF NOT THE CHECK NEXT POSSIBILITY
         MVI   CCW000E,X'8B'      OTHERWISE, SET PROPER MACHINE CONTROL
         B     PRNT000E           AND BRANCH TO REMAINING PRINT CODE
*
DEFAULTE MVI   CCW000E,X'0B'      DEFAULT TO SINGLE SPACING
*
* NOW WE CAN STORE THE CORRECT CHANNEL ADDRESS WORD, AND ISSUE THE
* START I/O COMMAND.
*
PRNT000E DS    0H
         BCTR  R11,R0             ADJUST BUFFER LENGTH FOR CARRIAGE CTL
         STCM  R15,7,CCW000E2+1   MOVE BUFFER ADDR INTO THE CCW
         STH   R11,CCW000E2+6     MOVE BUFFER LENGTH INTO THE CCW
*
         ST    R14,X'48'          STORE THE ADDRESS IN THE CAW AREA
         SIO   X'00E'             START THE I/O OPERATION
*
* NOW, WE WILL ACT ACCORDING TO THE CC SET BY THE SIO COMMAND.
*
CHKCODEE DS    0H
         BC    4,CSW000E          ON CC=1 TEST FOR END-OF-FILE
         BC    2,BUSY000E         ON CC=2 CHANNEL IS BUSY (BAD!)
         BC    1,NOP000E          ON CC=3 DEVICE NOT OPERATIONAL
*
* AT THIS POINT, WE HAVE HAD A SUCCESSFUL START OF THE I/O OPERATION.
* WE MUST NOW MARK THE UCB AS BUSY.
*
         MVC   TCBTSSIO(4),X'50'  STORE TIME THAT I/O STARTED
         L     R8,TCBTSLIC+4      GET TOTAL NUMBER OF I/O FOR TASK
         LA    R8,1(,R8)          INCREMENT TOTAL BY ONE
         ST    R8,TCBTSLIC+4      STORE NEW TOTAL
*
         L     R8,TCBTSLIC+16     GET TOTAL NUMBER OF I/O FOR DEVICE
         LA    R8,1(,R8)          INCREMENT TOTAL BY ONE
         ST    R8,TCBTSLIC+16     STORE NEW TOTAL
*
         ST    R12,UCBCURQE       STORE @ OF RQE AS THE CURRENT ONE
         MVI   UCBFLA,X'FF'       MARK THE UCB AS BUSY
         SR    R15,R15            SEND BACK A RETURN CODE OF 0
*
* NOW WE WILL BRANCH BACK TO THE BEGIN I/O ROUTINE.
*
DONE000E DS    0H
         LM    R0,R14,SIOESAVE    RESTORE CALLING ROUTNINE'S REG VALUES
         BR    R14                BRANCH BACK TO BEGIN I/O ROUTINE
*
* CONTROL COMES TO THIS SECTION OF CODE ONLY WHEN THE CHANNEL IS BUSY.
*
BUSY000E DS    0H
         XOPC  25
         DC    C'CHANNEL X''000E'' IS BUSY'
*
* THIS CODE IS EXECUTED WHEN WE GET A CC OF 1 FROM SIO (CSW STORED).
*
CSW000E  DS    0H
         XOPC  25
         DC    C'CSW FOR X''000E'' HAS BEEN STORED'
*
* THIS CODE IS EXECUTED WHEN WE GET A CC OF 3 FROM SIO (DEVICE
* IS NOT OPERATIONAL).
*
NOP000E  DS    0H
         XOPC  25
         DC    C'DEVICE ON CHANNEL ''000E'' IS NOT OPERATIONAL'
*
SIOESAVE DC    16F'-1'            SAVE AREA FOR CALLING RTN'S REGISTERS
CCW000E  CCW 1,0,X'40',1
CCW000E2 CCW 1,0,0,0
*
*
         EJECT
******
*
* SSSSS TTTTT   A   RRRR  TTTTT     IIIII     / OOOOO     ""  FFFFF  ""
* S       T    A A  R   R   T         I      /  O   O         F
* SSSSS   T   A   A RRRR    T         I     /   O   O         FFFF
*     S   T   AAAAA R R     T         I    /    O   O         F
* SSSSS   T   A   A R  R    T       IIIII /     OOOOO         F
*
*
* THIS IS THE START I/O FOR VIRTUAL PRINTER 2, WHOSE DEVICE ADDRESS IS
* X'000F'. UPON ENTRY TO THIS ROUTINE THE FOLLOWING REGISTERS VALUES
* MUST APPLY:
*
*      REG 3 ==> ADDRESS OF THE CVT
*      REG 4 ==> ADDRESS OF THE TCB REQUESTING THE I/O
*      REG 5 ==> ADDRESS OF THE RB FOR THE TCB ABOVE
*      REG 7 ==> ADDRESS OF THE UCB ASSOCIATED WITH THIS DEVICE
*      REG 10 ==> ENTRY ADDRESS OF THE SIO ROUTINE
*      REG 12 ==> POINTER TO THE RQE REQUESTING THE I/O OPERATION
*      REG 14 ==> RETURN ADDRESS FROM THE SIO ROUTINE
*
******
SIO000F  DS    0D
         USING SIO000F,R10        SET UP ADDRESSABILITY
*
         B     GO000F             BRANCH AROUND CCW @
         DC    A(CCW000F2+8)      ADDRESS OF END OF CHANNEL PROGRAM
GO000F   DS    0H
*
         USING CVT,R3
         USING TCB,R4
         USING RB,R5
         USING UCB,R7
         USING RQE,R12
*
         STM   R0,R15,SIOFSAVE    SAVE REGISTERS UPON ENTRY
*
* FIRST, WE WILL MODIFY THE CCW TO REFLECT THE PARTICULAR I/O OPERATION
* ABOUT TO BE PERFORMED. THE INFORMATION THAT ENABLES US TO DO THIS IS
* LOCATED WITHIN THE IOB.
*
         L     R1,RQEIOB          GET ADDRESS OF THE ASSOCIATED IOB
         USING IOB,R1             SET UP ADDRESSABILITY INTO IOB
*
* THIS IS WHERE WE ACCOUNT FOR CARRIAGE CONTROL.
*
         L     R2,IOBUFADD        GET THE ACTUAL PRINT BUFFER ADDRESS
         LH    R11,IOBUFLEN       GET BUFFER LEN
         LA    R15,1(,R2)         R15 ==> FIRST CHARACTER TO BE PRINTED
         LA    R14,CCW000F2       BY DEFAULT, EXECUTE ONLY ONE CCW
*
         CLI   0(R2),C'+'         ARE WE TO SUPPRESS SPACING?
         BE    PRNT000F           IF SO THEN EXECUTE ONLY ONE CCW
*
* HERE, WE MUST TRANSLATE THE USER-SUPPLIED ANSI CARRIAGE CONTROL TO
* MACHINE CARRIAGE CONTROL.
*
         LA    R0,8               SINCE WE HAVE CARRIAGE CONTROL,
         SR    R14,R0             WE WILL EXECUTE A 2-CCW PRINT PROGRAM
         STCM  R2,7,CCW000F+1     MOVE BUFFER ADDR INTO THE CCW
*
         CLI   0(R2),C'0'         PERFORM DOUBLE SPACING?
         BNE   TRIP000F           IF NOT THE CHECK NEXT POSSIBILITY
         MVI   CCW000F,X'13'      OTHERWISE, SET PROPER MACHINE CONTROL
         B     PRNT000F           AND BRANCH TO REMAINING PRINT CODE
*
TRIP000F CLI   0(R2),C'-'         PERFORM TRIPLE SPACING?
         BNE   PAGE000F           IF NOT THE CHECK NEXT POSSIBILITY
         MVI   CCW000F,X'1B'      OTHERWISE, SET PROPER MACHINE CONTROL
         B     PRNT000F           AND BRANCH TO REMAINING PRINT CODE
*
PAGE000F CLI   0(R2),C'1'         ADVANCE TO NEXT PAGE?
         BNE   DEFAULTF           IF NOT THE CHECK NEXT POSSIBILITY
         MVI   CCW000F,X'8B'      OTHERWISE, SET PROPER MACHINE CONTROL
         B     PRNT000F           AND BRANCH TO REMAINING PRINT CODE
*
DEFAULTF MVI   CCW000F,X'0B'      DEFAULT TO SINGLE SPACING
*
* NOW WE CAN STORE THE CORRECT CHANNEL ADDRESS WORD, AND ISSUE THE
* START I/O COMMAND.
*
PRNT000F DS    0H
         BCTR  R11,R0             ADJUST BUFFER LENGTH FOR CARRIAGE CTL
         STCM  R15,7,CCW000F2+1   MOVE BUFFER ADDR INTO THE CCW
         STH   R11,CCW000F2+6     MOVE BUFFER LENGTH INTO THE CCW
*
         ST    R14,X'48'          STORE THE ADDRESS IN THE CAW AREA
         SIO   X'00F'             START THE I/O OPERATION
*
* NOW, WE WILL ACT ACCORDING TO THE CC SET BY THE SIO COMMAND.
*
CHKCODEF DS    0H
         BC    4,CSW000F          ON CC=1 TEST FOR END-OF-FILE
         BC    2,BUSY000F         ON CC=2 CHANNEL IS BUSY (BAD!)
         BC    1,NOP000F          ON CC=3 DEVICE NOT OPERATIONAL
*
* AT THIS POINT, WE HAVE HAD A SUCCESSFUL START OF THE I/O OPERATION.
* WE MUST NOW MARK THE UCB AS BUSY.
*
         MVC   TCBTSSIO(4),X'50'  STORE TIME THAT I/O STARTED
         L     R8,TCBTSLIC+4      GET TOTAL NUMBER OF I/O FOR TASK
         LA    R8,1(,R8)          INCREMENT TOTAL BY ONE
         ST    R8,TCBTSLIC+4      STORE NEW TOTAL
*
         L     R8,TCBTSLIC+20     GET TOTAL NUMBER OF I/O FOR DEVICE
         LA    R8,1(,R8)          INCREMENT TOTAL BY ONE
         ST    R8,TCBTSLIC+20     STORE NEW TOTAL
*
         ST    R12,UCBCURQE       STORE @ OF RQE AS THE CURRENT ONE
         MVI   UCBFLA,X'FF'       MARK THE UCB AS BUSY
         SR    R15,R15            SEND BACK A RETURN CODE OF 0
*
* NOW WE WILL BRANCH BACK TO THE BEGIN I/O ROUTINE.
*
DONE000F DS    0H
         LM    R0,R14,SIOFSAVE    RESTORE CALLING ROUTNINE'S REG VALUES
         BR    R14                BRANCH BACK TO BEGIN I/O ROUTINE
*
* CONTROL COMES TO THIS SECTION OF CODE ONLY WHEN THE CHANNEL IS BUSY.
*
BUSY000F DS    0H
         XOPC  25
         DC    C'CHANNEL X''000F'' IS BUSY'
*
* THIS CODE IS EXECUTED WHEN WE GET A CC OF 1 FROM SIO (CSW STORED).
*
CSW000F  DS    0H
         XOPC  25
         DC    C'CSW FOR X''000F'' HAS BEEN STORED'
*
* THIS CODE IS EXECUTED WHEN WE GET A CC OF 3 FROM SIO (DEVICE
* IS NOT OPERATIONAL).
*
NOP000F  DS    0H
         XOPC  25
         DC    C'DEVICE ON CHANNEL ''000F'' IS NOT OPERATIONAL'
*
SIOFSAVE DC    16F'-1'            SAVE AREA FOR CALLING RTN'S REGISTERS
CCW000F  CCW 1,0,X'40',1
CCW000F2 CCW 1,0,0,0
         DROP  R3,R4,R5,R7,R10,R12
         EJECT
*
*         >     IIIII     / OOOOO      SSSSS V   V CCCCC      <
*          >      I      /  O   O      S     V   V C         <
*           >     I     /   O   O      SSSSS V   V C        <
*          >      I    /    O   O          S  V V  C         <
*         >     IIIII /     OOOOO      SSSSS   V   CCCCC      <
*
*
* THE FOLLOWING CODE COMPRISES THE SVC 0 MODULE. IT PERFORMS I/O
* SUCH AS READING A RECORD OR PRINTING A LINE. UPON ENTRY TO THIS
* ROUTINE, THE FOLLOWING REGISTER VALUES APPLY (AS SET BY THE SVC FLIH)
*
* IF THE DEVICE ADDRESS GIVEN IN THE IOB IS ZERO, XREAD OR XPRINT
* OUTPUT IS PERFORMED. OTHERWISE, A CHANNEL PROGRAM IS EXECUTED THAT
* CORRESPONDS TO THE DEVICE AT THE GIVEN ADDRESS.
*
*   REG 3 = ADDRESS OF THE CVT
*   REG 4 = ADDRESS OF THE CURRENT TCB
*   REG 5 = ADDRESS OF THE CURRENT RB
*   REG 6 = STARTING ADDRESS OF THIS ROUTINE
*   REG 14 = RETURN ADDRESS TO SVC FLIH
*
* THE COMPLETE REGISTER USAGE OF THIS ROUTINE IS AS FOLLOWS:
*
*   REG 1 = POINTER TO I/O CONTROL BLOCK PASSED BY USER
*   REG 2 = USAGE NOT DEFINED
*   REG 3 = ADDRESS OF THE CVT
*   REG 4 = ADDRESS OF THE CURRENT TCB
*   REG 5 = ADDRESS OF THE CURRENT RB
*   REG 6 = BASE REGISTER FOR SVC 0 ROUTINE
*   REG 7 = ADDRESS OF THE I/O BUFFER
*   REG 8 = LENGTH (SIZE) OF THE I/O BUFFER
*   REG 9 = USAGE NOT DEFINED
*   REG 10 = USAGE NOT DEFINED
*   REG 11 = USAGE NOT DEFINED
*   REG 12 = USAGE NOT DEFINED
*   REG 13 = USAGE NOT DEFINED
*   REG 14 = RETURN ADDRESS TO SVC FLIH
*   REG 15 = RETURN CODE FROM THE I/O OPERATION
*
* UPON EXIT FROM THIS ROUTINE, THE FOLLOWING RETURN CODES ARE POSSIBLE
*
*   R15 = 0 IF I/O WAS SUCCESSFUL
*   R15 = 4 IF EOF WAS ENCOUNTERED ON A READ
*   R15 = 8 IF THE I/O BLOCK WAS INVALID
*
         ORG   FIRST4K+X'7000'
SVC0RTN  DS    0D
*
* ESTABLISH ADDRESSIBILITY INTO THE VARIOUS CONTROL BLOCKS, AS WELL
* AS INTO THIS ROUTINE.
*
         USING SVC0RTN,R6         USE REG 6 AS OUR BASE REGISTER
*
         USING CVT,R3             ESTABLISH ADDRESSIBILITY INTO CVT
         USING TCB,R4             ESTABLISH ADDRESSIBILITY INTO TCB
         USING RB,R5              ESTABLISH ADDRESSIBILITY INTO RB
*
* THE IOB ADDRESS IS PASSED THROUGH THE SVC FLIH.
*
         USING IOB,R1             ESTABLISH ADDRESSIBILITY INTO I/O BLK
*
* NOW WE WILL ATTEMPT TO VALIDATE THE I/O PASSED TO US BY THE USER.
* THERE ARE THREE TESTS THAT WE MUST PERFORM. THEY ARE:
*
*   (1) THE FIRST THREE BYTES OF THE IOB MUST BE 'IOB'
*   (2) THERE MUST BE EITHER X'01' OR X'02' IN THE OPCODE OF THE IOB
*   (3) THE DEVICE ADDRESS MUST BE ZERO.
*
         XR    R15,R15            SET DEFAULT RC TO 'I/O SUCCESSFUL'
*
         CLC   IOBIDENT(3),IOBSTR 1ST THREE BYTES OF IOB MUST BE 'IOB'
         BNE   IOBINVAL           IF NOT, EXIT WITH RC = 8
*
         L     R7,IOBUFADD        OBTAIN @ OF USER INPUT BUFFER
         LH    R8,IOBUFLEN        OBTAIN LENGTH OF INPUT BUFFER
*
         CLC   IOBDEVAD(2),IOBADDEV CHECK IF IOB DEVICE ADD IS X'0000'
         BNE   DIRECTIO             IF NOT THEN GO TO RQEENQ ROUTINE
*
         CLI   IOBOPCDE,X'01'     CHECK IF IOB OPCODE IS X'01'
         BE    SVC0WRTE           IF SO, BRANCH TO CORRECT RTN
         CLI   IOBOPCDE,X'02'     CHECK IF IOB OPCODE IS X'02'
         BE    SVC0READ           IF SO, BRANCH TO CORRECT RTN
         B     IOBINVAL           OTHERWISE, THE OPCODE IS INVALID
*
* THIS IS WHERE A READ OPERATION (IOB OPCODE X'2A') IS PERFORMED.
*
SVC0READ DS    0H
         XREAD 0(0,R7),(R8)       READ A RECORD INTO THE USER BUFFER
         BM    EOFHIT             IF EOF WAS HIT, EXIT SVC 0 WITH RC 4
         CLC   0(8,R7),EOFMARK    CHECK IF CARD HAS '9'S IN 1ST 9 POS
         BE    EOFHIT             IF SO, CONSIDER THIS AN EOF MARKER
         BR    R14                OTHERWISE, THE READ WAS SUCCESSFUL
*
EOFHIT   DS    0H
         LA    R15,4              OTHERWISE, SET RC = 'EOF FOUND'
         BR    R14                AND EXIT SVC 0
*
* THIS IS WHERE A PRINT OPERATION (IOB OPCODE X'1A') IS PERFORMED.
*
SVC0WRTE DS    0H
         XPRNT 0(0,R7),(R8)       PRINT THE STRING POINTED AT IN IOB
         BR    R14                AND EXIT SVC 0
*
* THIS SECTION OF CODE RECEIVES CONTROL WHEN THE I/O OPERATION IS
* TO BE DONE VIA AN RQE/UCB. THIS OCCURS WHEN THE DEVICE ADDRESS FIELD
* IN THE IOB IS NON-ZERO.
*
* FIRST, WE WILL ENSURE THAT THE IOB CONTAINS A VALID OPCODE (X'01' FOR
* PRINT, OR X'02' FOR READ). THIS INFORMATION IS USED LATER IN THE I/O
* FLIH TO DETERMINE WHETHER END-OF-FILE HAS BEEN REACHED ON A READ
* OPERATION.
*
DIRECTIO DS    0H
         CLI   IOBOPCDE,X'01'     CHECK IF IOB OPCODE IS X'01'
         BE    TAGOUTPT           FOR PRINT REQUESTS, TAG OUTPUT BUFFER
         CLI   IOBOPCDE,X'02'     CHECK IF IOB OPCODE IS X'02'
         BE    IOBOKAY            IF SO, THE OPCODE IS VALID
         B     IOBINVAL           OTHERWISE, THE OPCODE IS INVALID
*
* FOR PRINT REQUESTS, WE WILL OVERLAY THE RIGHTMOST CHARACTER IN THE
* OUTPUT BUFFER WITH EITHER C'E' OR C'F', TO IDENTIFY THE VIRTUAL
* PRINTER TO WHICH THE REQUEST WAS SENT. THE CHARACTER THAT IS TWO
* POSITIONS FROM THE RIGHTMOST BYTE OF THE BUFFER WILL BE OVERLAYED
* WITH A UNIQUE TCB CHARACTER, TO HELP DETERMINE WHICH TASK ISSUED THE
* PRINT REQUEST.
*
TAGOUTPT DS    0H
         ICM   R9,1,IOBDEVAD+1    GET RIGHTMOST PORTION OF DEVICE ADDR
         LA    R9,X'B7'(,R9)      CONVERT INTO PRINTABLE FORM
*
         LA    R10,0(R7,R8)       GET ADDRESS OF THE END OF BUFFER
         BCTR  R10,R0             ADJUST TO POINT TO LAST BYTE
         STCM  R9,1,0(R10)        STORE PRINTER SIGNATURE BYTE
*
         BCTR  R10,R0              POINT TO END LOCATION MINUS 2 BYTES
         MVC   0(1,R10),TCBTNAME+3 STORE THE TASK IDENTIFIER BYTE
*
* NOW WE ARE READY TO ENQUEUE THE I/O REQUEST.
*
IOBOKAY  DS    0H
         L     R6,CVTRQENQ        GET ADDRESS OF RQE ENQUEUE ROUTINE
         BR    R6                 BRANCH TO RQE ENQUEUE ROUTINE
*
* WE ONLY EXIT THE ROUTINE HERE WHEN THE IOB IS INVALID.
*
IOBINVAL DS    0H
         LA    R15,8              SET RETURN CODE TO 'IOB INVALID'
         BR    R14                BRANCH BACK TO SVC FLIH
*
IOBSTR   DC    CL3'IOB'           IOB INDENTIFIER STRING
IOBADDEV DC    X'0000'            VALID I/O DEVICE ADDRESS
EOFMARK  DC    8CL1'9'            EOF MARKER FOR INPUT RECORDS
         DROP  R3,R4,R5,R6
         EJECT
*
*       >     W   W   A   IIIII TTTTT     SSSSS V   V CCCCC     <
*        >    W   W  A A    I     T       S     V   V C        <
*         >   W   W A   A   I     T       SSSSS V   V C       <
*        >    W W W AAAAA   I     T           S  V V  C        <
*       >      W W  A   A IIIII   T       SSSSS   V   CCCCC     <
*
*
* THE FOLLOWING CODE COMPRISES THE SVC 1 WAIT SERVICE. IT MODIFES
* THE DISPATCHABILITY OF THE GIVEN TCB.
*
*   REG 3 = ADDRESS OF THE CVT
*   REG 4 = ADDRESS OF THE CURRENT TCB
*   REG 5 = ADDRESS OF THE CURRENT RB
*   REG 6 = STARTING ADDRESS OF THIS ROUTINE
*   REG 14 = RETURN ADDRESS TO SVC FLIH
*
* THE COMPLETE REGISTER USAGE OF THIS ROUTINE IS AS FOLLOWS:
*
*   REG 1 = POINTER TO EVENT CONTROL BLOCK
*   REG 2 = USAGE NOT DEFINED
*   REG 3 = ADDRESS OF THE CVT
*   REG 4 = ADDRESS OF THE CURRENT TCB
*   REG 5 = ADDRESS OF THE CURRENT RB
*   REG 6 = BASE REGISTER FOR SVC 1 ROUTINE
*   REG 7 = USAGE NOT DEFINED
*   REG 8 = USAGE NOT DEFINED
*   REG 9 = USAGE NOT DEFINED
*   REG 10 = USAGE NOT DEFINED
*   REG 11 = USAGE NOT DEFINED
*   REG 12 = USAGE NOT DEFINED
*   REG 13 = USAGE NOT DEFINED
*   REG 14 = RETURN ADDRESS TO SVC FLIH
*   REG 15 = USAGE NOT DEFINED
*
SVC1RTN  DS    0D
*
* ESTABLISH ADDRESSIBILITY INTO THE VARIOUS CONTROL BLOCKS, AS WELL
* AS INTO THIS ROUTINE.
*
         USING SVC1RTN,R6         USE REG 6 AS OUR BASE REGISTER
*
         USING CVT,R3             ESTABLISH ADDRESSIBILITY INTO CVT
         USING TCB,R4             ESTABLISH ADDRESSIBILITY INTO TCB
         USING RB,R5              ESTABLISH ADDRESSIBILITY INTO RB
*
         TM    0(R1),X'40'        IS POST BIT ALREADY SET?
         BNZ   EXITSVC1           IF SO, DO NOTHING
*
         TM    0(R1),X'80'        WAIT/POST COMBINATION OF 1-0?
         BNZ   BADSVC1            IF SO THEN ABEND WITH A DUMP
*
         IC    R7,RBWCF           FETCH VALUE OF RB WAIT COUNT
         LA    R7,1(,R7)          INCREMENT WAIT COUNT BY 1
         STC   R7,RBWCF           STORE NEW VALUE OF RB WAIT COUNT
*
         OI    0(R1),X'80'        SET WAIT/POST BIT COMBO OF 1-0
         STCM  R5,7,1(R1)         STORE @ OF RB IN ECB
*
EXITSVC1 DS    0H
         BR    R14                BRANCH BACK TO SVC FLIH
*
* THIS SECTION OF CODE RECEIVES CONTROL WHEN WE HIT A WAIT/POST BIT
* COMBINATION OF 1-0.
*
BADSVC1  DS    0H
         XOPC  25                 ABEND WITH A DUMP
         DC    C'WAIT/POST BIT COMBINATION OF 1-0'
*
         EJECT
*
*       >     PPPP   OOO  SSSSS TTTTT     SSSSS V   V CCCCC     <
*        >    P   P O   O S       T       S     V   V C        <
*         >   PPPP  O   O SSSSS   T       SSSSS V   V C       <
*        >    P     O   O     S   T           S  V V  C        <
*       >     P      OOO  SSSSS   T       SSSSS   V   CCCCC     <
*
*
* THE FOLLOWING CODE COMPRISES THE SVC 0 POST SERVICE. IT MODIFES
* THE DISPATCHABILITY OF THE GIVEN TCB.
*
*   REG 3 = ADDRESS OF THE CVT
*   REG 4 = ADDRESS OF THE CURRENT TCB
*   REG 5 = ADDRESS OF THE CURRENT RB
*   REG 6 = STARTING ADDRESS OF THIS ROUTINE
*   REG 14 = RETURN ADDRESS TO SVC FLIH
*
* THE COMPLETE REGISTER USAGE OF THIS ROUTINE IS AS FOLLOWS:
*
*   REG 1 = POINTER TO EVENT CONTROL BLOCK
*   REG 2 = USAGE NOT DEFINED
*   REG 3 = ADDRESS OF THE CVT
*   REG 4 = ADDRESS OF THE CURRENT TCB
*   REG 5 = ADDRESS OF THE CURRENT RB
*   REG 6 = BASE REGISTER FOR SVC 2 ROUTINE
*   REG 7 = USAGE NOT DEFINED
*   REG 8 = USAGE NOT DEFINED
*   REG 9 = USAGE NOT DEFINED
*   REG 10 = USAGE NOT DEFINED
*   REG 11 = USAGE NOT DEFINED
*   REG 12 = USAGE NOT DEFINED
*   REG 13 = USAGE NOT DEFINED
*   REG 14 = RETURN ADDRESS TO SVC FLIH
*   REG 15 = USAGE NOT DEFINED
*
SVC2RTN  DS    0D
*
* ESTABLISH ADDRESSIBILITY INTO THE VARIOUS CONTROL BLOCKS, AS WELL
* AS INTO THIS ROUTINE.
*
         USING SVC2RTN,R6         USE REG 6 AS OUR BASE REGISTER
*
         L     R5,0(,R1)          OBTAIN ADDRESS OF THE RB IN QUESTION
         USING RB,R5              ESTABLISH ADDRESSIBILITY INTO RB
*
         TM    0(R1),X'40'        IS POST BIT ALREADY SET?
         BNZ   EXITSVC2           IF SO, DO NOTHING
*
         MVC   WAITPOST(1),0(R1)  SAVE THE CURRENT WAIT/POST BITS
         ST    R0,0(,R1)          MOVE BITS 2-31 OF PC TO THE ECB
         NI    0(R1),X'3F'        CLEAR OUT BITS 0 AND 1
         OI    0(R1),X'40'        CHANGE WAIT/POST TO 0-1
*
         TM    WAITPOST,X'80'     DO WE HAVE A WAIT/POST CODE OF 1-0?
         BZ    EXITSVC2           IF NOT THEN EXIT THE SVC MODULE
*
         CLC   RBTYPE(4),SVC2RB1  IS THIS A PROGRAM REQUEST BLOCK?
         BE    GOODRB             IF SO THEN THE RB IS VALID
         CLC   RBTYPE(4),SVC2RB2  IS THIS A SUPERVISOR REQUEST BLOCK?
         BE    GOODRB             IF SO THEN THE RB IS VALID
*
         L     R15,CVTBRABN       OTHERWISE, BRANCH TO ABEND CODE
         BR    R15
*
GOODRB   DS    0H
         IC    R7,RBWCF           FETCH VALUE OF RB WAIT COUNT
         BCTR  R7,R0              DECREMENT WAIT COUNT BY 1
         STC   R7,RBWCF           FETCH VALUE OF RB WAIT COUNT
*
EXITSVC2 DS    0H
         BR    R14                BRANCH BACK TO SVC FLIH
*
* THIS SECTION OF CODE RECEIVES CONTROL WHEN WE HIT A WAIT/POST BIT
* COMBINATION OF 1-0.
*
BADSVC2  DS    0H
         XOPC  25                 ABEND WITH A DUMP
         DC    C'WAIT/POST BIT COMBINATION OF 1-0'
*
SVC2RB1  DC    CL4'PRB '
SVC2RB2  DC    CL4'SVRB'
WAITPOST DC    C'0'
         EJECT
*
*   >     RRRR  BBBB     K   K IIIII L     L     EEEEE RRRR      <
*    >    R   R B   B    K  K    I   L     L     E     R   R    <
*     >   RRRR  BBBB     KKK     I   L     L     EEE   RRRR    <
*    >    R R   B   B    K  K    I   L     L     E     R R      <
*   >     R  R  BBBB     K   K IIIII LLLLL LLLLL EEEEE R  R      <
*
*
* THE FOLLOWING CODE COMPRISES THE SVC 3 MODULE. THIS MODULE GETS
* CONTROL UPON TERMINATION OF A PROGRAM OR NON-TYPE 1 SVC. IT WILL
* REMOVE THE PRB OR SVRB FROM THE TOP OF THE LIST AND ACTIVATE THE
* NEXT ONE, WHILE RETURNING THE USED RB TO THE CONTROL BLOCK POOL.
* UPON ENTRY TO THIS ROUTINE, THE REGISTERS ARE TO CONTAIN THE
* THE FOLLOWING VALUES:
*
*   REG 3 = ADDRESS OF THE CVT
*   REG 4 = ADDRESS OF THE CURRENT TCB
*   REG 5 = ADDRESS OF THE CURRENT RB
*   REG 14 = RETURN ADDRESS TO SVC FLIH
*
* THE COMPLETE REGISTER USAGE OF THIS ROUTINE IS AS FOLLOWS:
*
*   REG 1 = USAGE NOT DEFINED
*   REG 2 = USAGE NOT DEFINED
*   REG 3 = ADDRESS OF THE CVT
*   REG 4 = ADDRESS OF THE CURRENT TCB
*   REG 5 = ADDRESS OF THE CURRENT RB
*   REG 6 = BASE REGISTER FOR SVC 3 ROUTINE
*   REG 7 = USAGE NOT DEFINED
*   REG 8 = USAGE NOT DEFINED
*   REG 9 = USAGE NOT DEFINED
*   REG 10 = WORK REGISTER 1 (USED IN FRECB100 MACRO)
*   REG 11 = WORK REGISTER 2 (USED IN FRECB100 MACRO)
*   REG 12 = USAGE NOT DEFINED
*   REG 13 = USAGE NOT DEFINED
*   REG 14 = RETURN ADDRESS TO SVC FLIH
*   REG 15 = USAGE NOT DEFINED
*
SVC3RTN  DS    0D
*
         USING CVT,R3             ESTABLISH ADDRESSIBILITY INTO CVT
         USING TCB,R4             ESTABLISH ADDRESSIBILITY INTO TCB
         USING RB,R5              ESTABLISH ADDRESSIBILITY INTO RB
         USING SVC3RTN,R6         ESTABLISH A BASE REGISTER
*
         STM   R0,R1,RBGRSAVE     STORE RETURN REG VALUES IN RB
         ST    R15,RBGRSAVE+15*4
*
* THIS IS WHERE WE TEST WHETHER OR NOT TO TAKE THE 'MERCY' EXIT.
* THE 'MERCY' EXIT ONLY APPILES TO SPIE EXIT ROUTINES, WHICH RUN
* UNDER THE PRB AND THUS SHOULD NOT BE KILLED.
*
         CLC   OLDTYPE2+5(3),MERCYSVC+1 WAS SVC CALL THE MERCY SVC 3?
         BNE   NOMERCY                  IF NOT THEN KILL THE RB
*
* THIS IS THE 'MERCY' EXIT. IT IS USED ONLY BY SPIE EXIT ROUTINES,
* WHICH RUN UNDER THE PRB.
*
         L     R7,TCBPIE          GET ADDRESS OF SCA FROM TCB
         L     R7,0(,R7)          GET ADDRESS OF PIE FROM SCA
*
         TM    TCBPIE,X'80'       IS THE TCB BUSY BIT OFF?
         BZ    NOMERCY            IF SO THEN HAVE NO MERCY
         TM    0(R7),X'80'        IS THE PIE BUSY BIT OFF?
         BZ    NOMERCY            IF SO THEN HAVE NO MERCY
*
         NI    TCBPIE,X'7F'       TURN OFF BUSY BIT IN TCB
         NI    0(R7),X'7F'        TURN OFF BUSY BIT IN PIE
*
         MVC   TCBGRS+14*4(8),12(R7) COPY REGS 14 AND 15 INTO TCB
         MVC   TCBGRS(12),20(R7)     COPY REGS 0 THRU 2 TO TCB
         MVC   RBOPSW+4(4),8(R7)     COPY RIGHT HALF OF PSW INTO RB
*
         L     R15,TCBGRS+15*4    LOAD REGS 15 THRU 1 FOR USER
         LM    R0,R1,TCBGRS
         B     EXITSVC3           EXIT THE SVC 3 MODULE
*
* HERE IS WHERE WE REMOVE THE CURRENT RB FROM THE CHAIN. IF IT IS
* LAST RB IN THE CHAIN THEN WE WILL SET THE TCBRB FIELD TO ZERO.
*
NOMERCY  DS    0H
*
         MVC   TCBGRS(16*4),RBGRSAVE MOVE RB REG VALUES TO TCB AREA
         MVC   TCBFRS(4*8),RBFRSAVE  MOVE FLOATING REG VALUES TO TCB
*
         CLM   R4,7,RBLINK+1      IS THIS THE LAST RB IN THE CHAIN?
         BNE   NEXTRB             IF NOT THEN CONTINUE NORMALLY
         TM    RBFLGS3,X'80'      IS THE TCB FLAG SET IN THE RBLINK?
         BZ    NEXTRB             IF NOT THEN CONTINUE NORMALLY
*
         XC    TCBRB(4),TCBRB     ZERO OUT THE RB PTR IN TCB
         B     FREECB
*
NEXTRB   DS    0H
         MVC   TCBRB+1(3),RBLINK+1 STORE @ OF NEXT REQ. BLK IN TCB
*
* WE WILL NOT ACTUALLY FREE THE REQUEST BLOCK IN THIS VERSION OF SOS.
*
FREECB   DS    0H
         MVC   SVC3RBID(4),RBTYPE
         MVC   RBCDE(4),OLDRBID   SET RB CODE FIELD TO 'NOTC'
         LR    R10,R5             SAVE @ OF REQ BLK TO SAVE
         L     R5,TCBRB           GET @ OF THE NEW CURRENT RB
*
         CLC   SVC3RBID(4),SVC3SVRB
         BNE   EXITSVC3
         FRECB100 CBREG=R10
*
EXITSVC3 DS    0H
         BR    R14                BRANCH BACK TO THE SVC FLIH
*
         DROP  R6
OLDRBID  DC    CL4'NOTC'          USED RB IDENTIFIER
MERCYSVC DC    A(PCHKFLIH)        ADDRESS OF THE MERCY EXIT SVC CALL
SVC3RBID DC    CL4' '
SVC3SVRB DC    CL4'SVRB'
         EJECT
*
* THE FOLLOWING CODE COMPRISES THE SVC 8 MODULE. IT IS SUPPLIED
* THROUGH THE USE OF THE MACRO 'LOADERC'.
*
         ORG   FIRST4K+X'7300'
SVC8RTN  DS    0D
         LOADERC
         EJECT
*
* THE SVC 13 "ABEND" MODULE WILL BE LOADED AT THIS LOCATION UPON ENTRY
* TO NIP/MS.
*
         ORG   FIRST4K+X'7500'
SVC13RTN DS    0D
         EJECT
*
*       >      SSSSS PPPPP IIIII EEEEE    SSSSS V   V CCCCC     <
*        >     S     P   P   I   E        S     V   V C        <
*         >    SSSSS PPPPP   I   EEE      SSSSS V   V C       <
*        >         S P       I   E            S  V V  C        <
*       >      SSSSS P     IIIII EEEEE    SSSSS   V   CCCCC     <
*
*
* THE FOLLOWING CODE COMPRISES THE SVC 14 MODULE, WHICH WILL ESTABLISH
* OR CANCEL A USER SPIE ENVIRONMENT.
*
* UPON ENTRY TO THIS ROUTINE, THE REGISTERS ARE TO CONTAIN THE
* THE FOLLOWING VALUES:
*
*   REG 1 = ADDRESS OF THE USER PICA. IF REG 1 = 0 THEN THIS IS A
*          REQUEST TO CANCEL AN ALREADY EXISTING SPIE ENVIRONMENT. THE
*          SPIE ENVIRONMENT WILL ALSO BE CANCELLED IF THE EXIT ROUTINE
*          IS ZERO OR NO INTERRUPTS ARE SPECIFIED IN THE PICA.
*   REG 3 = ADDRESS OF THE CVT
*   REG 4 = ADDRESS OF THE CURRENT TCB
*   REG 5 = ADDRESS OF THE CURRENT RB
*   REG 14 = RETURN ADDRESS FROM THIS MODULE
*
* THE COMPLETE REGISTER USAGE OF THIS ROUTINE IS AS FOLLOWS:
*
*   REG 1 = ADDRESS OF THE PICA
*   REG 2 = USAGE NOT DEFINED
*   REG 3 = ADDRESS OF THE CVT
*   REG 4 = ADDRESS OF THE CURRENT TCB
*   REG 5 = ADDRESS OF THE CURRENT RB
*   REG 6 = BASE REGISTER FOR SVC 14 MODULE
*   REG 7 = EXIT ADDRESS DEFINED IN THE USER'S PICA
*   REG 8 = ADDRESS OF PIE DEFINED IN THE USER'S 4K REGION
*   REG 9 = ADDRESS OF THE SCA
*   REG 10 = USAGE NOT DEFINED
*   REG 11 = USAGE NOT DEFINED
*   REG 12 = USAGE NOT DEFINED
*   REG 13 = USAGE NOT DEFINED
*   REG 14 = RETURN ADDRESS TO SVC FLIH
*   REG 15 = USAGE NOT DEFINED
*
         ORG   FIRST4K+X'7900'
SVC14RTN DS    0D
*
* ESTABLISH ADDRESSABILITY INTO THIS MODULE.
*
         USING SVC14RTN,R6        ESTABLISH ADDRESSABILITY
*
* WE MUST SET UP ADDRESSABILITY INTO OUR CONTROL BLOCK DSECTS.
*
         USING CVT,R3             ESTABLISH ADDRESSIBILITY INTO CVT
         USING TCB,R4             ESTABLISH ADDRESSIBILITY INTO TCB
         USING RB,R5              ESTABLISH ADDRESSIBILITY INTO RB
*
* THE USER IS NOT ALLOWED TO ISSUE THIS SERVICE FROM AN EXIT ROUTINE.
* IF IT WAS INVOKED FROM AN EXIT, THEN WE WILL ABEND THE USER PROGRAM
* WITH A E0E ABEND.
*
         TM    TCBPIE,X'80'       TEST IF BUSY BIT IS SET IN TCB
         BNZ   CRASHHIM           IF SO THEN ABEND HIS/HER PROGRAM
*
* THIS IS WHERE WE DETERMINE WHICH ACTION TO PERFORM. WE CAN EITHER
* ESTABLISH A NEW SPIE ENVIRONMENT OR CANCEL A PREVIOUSLY EXISTING ONE.
* WE WILL CANCEL A PREVIOUSLY EXISTING SPIE IF ANY OF THE FOLLOWING
* CONDITIONS ARE TRUE:
*
*    (1) THE PICA ADDRESS IN REG 1 IS ZERO UPON ENTRY,
*    (2) THE EXIT ADDRESS GIVEN IN THE PICA IS ZERO, OR
*    (3) NO INTERRUPTS ARE SPECIFIED WITHIN THE PICA.
*
SPIEACT  DS    0H
         LTR   R1,R1              IS THE PICA ADDRESS ZERO?
         BZ    CANCEL             IF SO, WE WILL DO A CANCEL OPERATION
*
         XR    R7,R7              CLEAR OUT REG 7
         ICM   R7,7,1(R1)         GET THE PICA'S SPIE EXIT ADDRESS
         LTR   R7,R7              IS THE PICA ADDRESS ZERO?
         BZ    CANCEL             IF SO, WE WILL DO A CANCEL OPERATION
*
         LH    R8,4(,R1)          GET INTERRUPTS-TO-PROCESS BITS
         BZ    CANCEL             IF NOT THEN DO A CANCEL OPERATION
*
         XR    R9,R9              CLEAR OUT REG 9
         CLM   R9,7,TCBPIE        GET ADDRESS OF THE SCA FOR THIS TASK
         BNE   MODSPIE            IF SO THEN MODIFY THE CURRENT ENVIR.
*
* THIS IS WHERE WE ESTABLISH A NEW SPIE ENVIRONMENT.
*
         LA    R9,TCBDMSCA        FIND ADDRESS OF THE SCA FOR THIS TASK
         ST    R9,TCBPIE          STORE IT IN TCBPIE
         L     R9,TCBAPIE         GET ADDRESS OF THE PIE IN USER REGION
         ST    R9,TCBDMSCA        STORE IT IN THE SCA
         LA    R1,0(,R1)          ENSURE THAT HIGH BIT IS NOT SET
         ST    R1,0(,R9)          STORE @ OF PICA IN THE PIE
*
         L     R5,RBLINK          GET ADDRESSABILITY INTO PRB
         MVC   TCBPIE(1),RBOPSW+4 MOVE PROGRAM MASK FROM THE PSW
         NI    TCBPIE,X'0F'       CLEAR LEFT HIT OF TCBPMASK
*
         NI    0(R1),X'0F'        CLEAR LEFT HIT OF MASK IN THE PICA
         NI    RBOPSW+4,X'F0'     CLEAR THE PGM MASK IN USER PSW
         OC    RBOPSW+4(1),0(R1)  MOVE PGM MASK FROM PICA TO USER PSW
*
         XR    R1,R1              RETURN @ OF PREV. PICA (NONE)
         B     EXITSPIE           EXIT THIS MODULE
*
* THIS IS WHERE WE GO WHEN WE ARE MODIFYING AN ALREADY EXISTING
* SPIE ENVIRONMENT.
*
MODSPIE  DS    0H
*
         L     R7,TCBPIE          GET ADDRESS OF THE SCA
         L     R7,0(,R7)          GET ADDRESS OF THE PIE
         TM    0(R7),X'80'        TEST IF BACKUP BUSY BIT IS SET IN PIE
         BNZ   CRASHHIM           IF SO THEN ABEND HIS/HER PROGRAM
*
         L     R9,TCBPIE          OBTAIN @ OF THE SPIE CTL AREA
         L     R9,0(,R9)          GET ADDRESS OF THE PIE FROM THE SCA
         L     R2,0(,R9)          GET LOCATION OF THE EXISTING PICA
         ST    R1,0(,R9)          STORE @ OF PICA IN THE PIE
*
         L     R5,RBLINK          GET ADDRESSABILITY INTO PRB
         NI    0(R1),X'0F'        CLEAR LEFT HIT OF MASK IN THE PICA
         NI    RBOPSW+4,X'F0'     CLEAR THE PGM MASK IN USER PSW
         OC    RBOPSW+4(1),0(R1)  MOVE PGM MASK FROM PICA TO USER PSW
*
         LR    R1,R2              PASS BACK ADDRESS OF PREV. PICA
         B     EXITSPIE           EXIT THIS MODULE
*
* THIS IS WHERE WE GO WHEN THE USER HAS REQUESTED FOR A CURRENT SPIE
* ENVIRONMENT TO BE CANCELLED.
*
CANCEL   DS    0H
*
         XR    R1,R1              RETURN A 0 TO USER IF NO SPIE ENV.
         L     R7,TCBPIE          GET ADDRESS OF THE SCA
         LTR   R7,R7              DOES A SPIE ENVIRONMENT EXIST?
         BZ    EXITSPIE           IF NOT THEN EXIT WITH REG 1 = 0
*
         L     R5,RBLINK          GET ADDRESSABILITY INTO PRB
         NI    RBOPSW+4,X'F0'     CLEAR THE PGM MASK IN USER PSW
         OC    RBOPSW+4(1),TCBPIE MOVE PGM MASK TO USER PSW FROM TCB
*
         L     R9,TCBPIE          OBTAIN @ OF THE SPIE CTL AREA
         L     R9,0(,R9)          GET ADDRESS OF THE PIE FROM THE SCA
         L     R1,0(,R9)          PASS BACK @ OF EXISTING PICA
         XC    0(32,R9),0(R9)     CLEAR OUT THE PIE
         XC    TCBPIE(4),TCBPIE   CLEAR OUT THE TCB PIE
         XC    TCBDMSCA(4),TCBDMSCA CLEAR OUT THE SPY CTL AREA
*
EXITSPIE DS    0H
         BR    R14
*
* CONTROL COMES HERE ONLY WHEN THE USER HAS ISSUED AN SVC 14 FROM A
* SPIE EXIT ROUTINE. THIS IS NOT ALLOWED, SO WE WILL ABEND THE USER
* PROGRAM.
*
CRASHHIM DS    0H
         L     R1,SPIECODE        LOAD THE ABEND CODE FOR SVC 13
         SVC   13                 INVOKE ABEND MODULE
*
SPIECODE DC    0F'0',X'80E0E000'  ABEND CODE E0E WITH DUMP
         DROP  R6
         EJECT
*
*              >      CCCCC H   H   A   PPPP      <
*               >     C     H   H  A A  P   P    <
*                >    C     HHHHH A   A PPPP    <
*               >     C     H   H AAAAA P        <
*              >      CCCCC H   H A   A P         <
*
*
* THE FUNCTION OF CHAP IS TO RE-ARRANGE THE TCBS IN THE ACTIVE CHAIN
* TO GIVE CERTAIN TASKS PRIORITY OVER OTHERS. SPECIFICALLY, CHAP WILL
* TAKE THE LOWEST USER TCB ON THE CHAIN AND SWITCH IT'S POSITION WITH
* THE HIGHEST.
*
* CHAP WILL THEN PROCEED TO EXIT TO THE DISPATCHER.
*
* THE COMPLETE REGISTER USAGE OF THIS ROUTINE IS AS FOLLOWS:
*
*   REG 1 = USAGE NOT DEFINED
*   REG 2 = USAGE NOT DEFINED
*   REG 3 = ADDRESS OF THE CVT
*   REG 4 = ADDRESS OF THE CURRENT TCB
*   REG 5 = ADDRESS OF THE CURRENT RB
*   REG 6 = BASE REGISTER
*   REG 7 = USAGE NOT DEFINED
*   REG 8 = USAGE NOT DEFINED
*   REG 9 = USAGE NOT DEFINED
*   REG 10 = USAGE NOT DEFINED
*   REG 11 = USAGE NOT DEFINED
*   REG 12 = USAGE NOT DEFINED
*   REG 13 = USAGE NOT DEFINED
*   REG 14 = USAGE NOT DEFINED
*   REG 15 = USAGE NOT DEFINED
*
         ORG   FIRST4K+((*-FIRST4K+31)/32*32)
CHAP     DS    0D
         USING CHAP,R6            SET UP ADDRESSABILITY INTO CHAP
*
         L     R3,76              GET ADDRESS OF THE CVT
         USING CVT,R3
         L     R4,CVTHEAD         LOAD ADDRESS OF FIRST TCB IN CHAIN
         USING TCB,R4
*
* NOW WE WILL RUN DOWN THE CHAIN OF TCBS AND FIND THE FIRST USER TCB
* ON THE ACTIVE CHAIN.
*
SCANTOP  DS    0H
         LTR   R4,R4              ARE WE AT THE END OF THE TCB CHAIN?
         BZ    EXITCHAP           IF SO THEN THERE ARE NONE TO SHUFFLE
*
         CLI   TCBLMP,X'F0'       IS THIS A USER TCB?
         BE    FOUNDTOP           IF SO THEN WE'VE FOUND THE TOP ONE
*
         L     R4,TCBTCB          POINT TO NEXT TCB IN THE CHAIN
         B     SCANTOP            TEST THE NEXT TCB IN THE CHAIN
*
* AT THIS POINT, WE HAVE FOUND THE FIRST USER TCB ON THE CHAIN. NOW WE
* CAN PROCEED TO FIND THE LAST USER TCB ON THE CHAIN.
*
FOUNDTOP DS    0H
         LR    R7,R4              SAVE ADDRESS OF FIRST USER TCB
*
SCANBOT  DS    0H
         LTR   R4,R4              ARE WE AT THE END OF THE TCB CHAIN?
         BZ    EXITCHAP           IF SO THEN THERE ARE NONE TO SHUFFLE
*
         CLI   TCBLMP,X'F0'       IS THIS A USER TCB?
         BNE   FOUNDBOT           IF SO THEN WE'VE FOUND THE TOP ONE
*
         LR    R8,R4              SAVE ADDRESS OF THIS TCB
         L     R4,TCBTCB          POINT TO NEXT TCB IN THE CHAIN
         B     SCANBOT            TEST THE NEXT TCB IN THE CHAIN
*
* NOW THAT WE HAVE FOUND BOTH THE TOP AND THE BOTTOM USER TCBS ON THE
* CHAIN, WE CAN NOW SWITCH THEIR POSITIONS.
*
FOUNDBOT DS    0H
         LR    R2,R4              SAVE ADDRESS OF WAIT TCB
*
         LR    R4,R8              GET ADDRESSABILITY INTO NEW 1 USR TCB
         L     R9,TCBBACK         SAVE ADDR. OF NEXT TO LAST TCB
         L     R10,TCBTCB         SAVE NEXT TCB AFTER OLD LAST USER TCB
         MVC   TCBBACK(4),CVTHEAD SET POINTER BACK TO NIP/MS TCB
         ST    R7,TCBTCB          STORE POINTER TO OLD 1ST TCB
*
         L     R4,CVTHEAD         GET ADDRESSABILITY INTO NIP/MS TCB
         ST    R8,TCBTCB          SET FORWARD LINK TO NEW 1ST USER TCB
*
         LR    R4,R9              RELOAD POINTER TO NEXT-TO-LAST TCB
         ST    R10,TCBTCB         CHAIN THIS TCB TO WAIT TCB
*
         LR    R4,R7              GET ADDRESSABILITY INTO OLD 1ST TCB
         ST    R8,TCBBACK         SET POINTER BACK TO NEW 1ST TCB
*
         LR    R4,R2              GET POINTER TO WAIT TCB
         ST    R9,TCBBACK         CHAIN THIS TCB TO WAIT TCB
*
* NOW WE WILL EXIT TO THE DISPATCHER.
*
EXITCHAP DS    0H
         L     R6,CVT0DS          GET ADDRESS OF THE DISPATCHER
         BR    R6                 BRANCH TO THE DISPATCHER
         EJECT
*
*     >     SSSSS V   V CCCCC     FFFFF L     IIIII H   H     <
*      >    S     V   V C         F     L       I   H   H    <
*       >   SSSSS V   V C         FFF   L       I   HHHHH   <
*      >        S  V V  C         F     L       I   H   H    <
*     >     SSSSS   V   CCCCC     F     LLLLL IIIII H   H     <
*
*
* THIS IS THE SVC FIRST LEVEL INTERRUPT HANDLER. IT TRANSFERS CONTROL
* TO THE APPROPRIATE SVC SLIH. UPON ENTRY TO THIS ROUTINE, THE REGISTER
* CONTENTS ARE STORED AND LATER RESTORED TO THEIR ORIGINAL STATE UPON
* ENTRY TO THIS ROUTINE. THE USER PROGRAM CAN THEN CONTINUE UNAFFECTED.
*
* REGISTER USAGE:
*
*   REG 0 = USAGE NOT DEFINED
*   REG 1 = USAGE NOT DEFINED
*   REG 2 = USAGE NOT DEFINED
*   REG 3 = ADDRESS OF THE CVT
*   REG 4 = ADDRESS OF THE CURRENT TCB
*   REG 5 = ADDRESS OF THE CURRENT RB
*   REG 6 = ADDRESS OF THE PROPER SVC SLIH OR ZERO IF NOT SUPPORTED
*   REG 7 = ADDRESS OF THE SVC TABLE
*   REG 8 = WORK REGISTER 1
*   REG 9 = ADDRESS OF THE SVC TABLE ENTRY FOR THE REQUESTED SVC #
*   REG 10 = WORK REGISTER 2
*   REG 11 = SVC # AS CODED BY THE USER
*   REG 12 = BASE REGISTER FOR SVC FLIH RTN
*   REG 13 = USAGE NOT DEFINED
*   REG 14 = USAGE NOT DEFINED
*   REG 15 = USAGE NOT DEFINED
*
         ORG   FIRST4K+X'9800'
SVCFLIH  DS    0D
*
* MOVE CURRENT TIMER VALUE TO LOW STORAGE AREA.
*
         MVC   LOWTIME(4),X'50'   COPY TIMER VALUE TO SAFE LOCATION
*
* FIRST WE MUST ENSURE THAT THE SVC WAS ISSUED FROM WITHIN THE TASK
* MODE. IF NOT, THEN THIS MAY BE A LOGIC ERROR AND WE SHOULD ABEND WITH
* A DUMP.
*
         CLI   LEVELFLG,C'T'      SVC SHOULD HAVE BEEN FROM PROB. LEVEL
         BNE   LEVELABN           IF NOT, ABEND WITH A DUMP
         MVI   LEVELFLG,C'S'      OTHERWISE, SET LEVEL TO 'SYSTEM'
*
* NOW WE WILL SAVE THE USER'S REGISTERS SO THAT WE CAN DO SOME WORK.
*
         STM   R0,R15,TYP2SAVE    STORE USER REGISTERS FOR LATER USE
*
         BALR  R12,R0             ESTABLISH A BASE REGISTER
         USING *,R12
*
* WE WILL NOW OBTAIN THE "STANDARD" REGISTER VALUE FOR THE INTERRUPT
* HANDLER. THESE ARE DEFINED AS FOLLOWS:
*
*  REG 3 = ADDRESS OF THE CVT (OBTAINED FROM BACKUP COPY AT X'4C')
*  REG 4 = ADDRESS OF THE CURRENT TCB
*  REG 5 = ADDRESS OF THE CURRENT RB
*
* ONCE WE HAVE THESE VALUES, WE CAN ALSO SET UP ADDRESSIBILITY INTO
* OUR DSECTS.
*
         L     R3,X'4C'           GET @ OF THE CVT
         L     R4,0(,R3)          GET @ OF TCB WORDS
         L     R4,4(,R4)          GET @ OF THE CURRENT TCB
         L     R5,0(,R4)          GET @ OF THE CURRENT RB
         USING CVT,R3             ESTABLISH ADDRESSIBILITY INTO CVT
         USING TCB,R4             ESTABLISH ADDRESSIBILITY INTO TCB
         USING RB,R5              ESTABLISH ADDRESSIBILITY INTO RB
*
* NOW WE WILL COMPUTE A VALUE TO BE ADDED TO TCBTCPU. THIS IS THE
* TOTAL CPU TIME ELAPSED BETWEEN DISPATCH OF THE RB AND THIS SVC.
*
         L     R8,TCBTDISP        GET CPU TIME AT DISPATCH
         S     R8,LOWTIME         SUBTRACT CPU TIME AT SVC INTERRUPT
         TM    OLDTYPE2+1,X'01'   WAS INTERRUPT IN SUPERVISOR STATE?
         BZ    ADDSTM2            IF SO THEN ADD TIME TO SUP. TOTAL
*
         A     R8,TCBTCPUP        ADD ELAPSED CPU TIME TO TCB TOTAL
         ST    R8,TCBTCPUP        AND STORE IT BACK INTO THE TCB FIELD
         B     TESTRB             BRANCH TO I/O PROCESSING CODE
*
ADDSTM2  DS    0H
         A     R8,TCBTCPUS        ADD ELAPSED CPU TIME TO TCB TOTAL
         ST    R8,TCBTCPUS        AND STORE IT BACK INTO THE TCB FIELD
*
* NOW WE MUST TEST WHETHER OR NOT A RB EXISTS. IF THE RB ADDRESS IS
* IS ZERO THEN IT IS INVALID, AND WE WILL ABEND WITH A DUMP.
*
TESTRB   DS    0H
         LTR   R5,R5              TEST FOR AN EXISTING RB
         BZ    RBERROR            IF NON-EXISTENT THEN BR. TO ERROR RTN
*
* MOVE THE USER REGISTER VALUES INTO THE TCB REGISTER SAVE AREA. THE
* DISPATCHER WILL RE-LOAD THEM JUST PRIOR TO GIVING CONTROL BACK TO
* THE USER PROGRAM.
*
         MVC   TCBGRS(64),TYP2SAVE  STORE USER REGS IN TCB SAVE AREA
*
         STD   0,TCBFRS             STORE THE FOATING POINT RREGISTERS
         STD   2,TCBFRS+1*8
         STD   4,TCBFRS+2*8
         STD   6,TCBFRS+3*8
*
* WE WILL ALSO STORE THE USER'S PSW INTO THE RB SO THAT THE TCB
* MAY LATER BE RE-DISPATCHED.
*
         MVC   RBOPSW(8),OLDTYPE2 STORE OLD PSW IN REQUEST BLOCK
*
* NOW WE WILL ATTEMPT TO DISPATCH THE PROPER SVC SECOND LEVEL INTERRUPT
* HANDLER BASED UPON THE SVC # CODED BY THE USER. THIS IS ACCOMPLISHED
* BY INDEXING THE SVC TABLE USING THE SVC # ITSELF, AND BRANCHING TO
* THE ADDRESS THAT IS READ FROM THE TABLE.
*
* BEFORE WE DO THIS, HOWEVER, WE MUST ENSURE THAT THE SVC # IS VALID.
* FIRST WE WILL TEST IF IT IS IN THE RANGE OF SUPPORTED SVCS.
*
         LH    R11,OLDTYPE2+2     FETCH SVC NUMBER FROM OLD PSW + 2
*
         LA    R10,MAXSVC#        LOAD THE HIGHEST SVC # RECOGNIZED
         CR    R11,R10            IS THE SVC # WITHIN THE VALID RANGE?
         BH    UNSVCHAN           IF NOT THEN ABEND WITH A DUMP
*
* HAVING DETERMINED THAT THE SVC # IS WITHIN THE VALID RANGE, WE CAN
* NOW ATTEMPT TO FIND THE PROPER ENTRY IN THE SVC TABLE.
*
         LR    R9,R11             PREPARE SVC # FOR COMPUTATION
         SLL   R9,3               COMPUTE THE OFFSET WITH THE SVC TABLE
*
         L     R7,CVTSVCTA        OBTAIN THE STARTING @ OF SVC TABLE
         AR    R9,R7              ADD THE STARTING @ TO COMPUTED DISPL.
*
* NOW WE WILL OBTAIN THE ACTUAL ADDRESS OF THE SVC SLIH FOR THE
* GIVEN SVC NUMBER. THIS ADDRESS IS STORED IN THE FIRST 4 BYTES OF EACH
* SVC TABLE ENTRY. IF THE ADDRESS IS ZERO THEN THE SVC IS NOT YET
* SUPPORTED, AND WE WILL SIMPLY ABEND WITH A DUMP. OTHERWISE, ARE
* READY TO BRANCH TO THE SVC SLIH.
*
         L     R6,0(,R9)          LOAD @ OF THE PROPER SVC HANDLER
         LTR   R6,R6              IS THE SVC SUPPORTED?
         BZ    UNSVCHAN           IF NOT, BRANCH TO ERROR RTN
*
         TM    4(R9),X'C0'        TEST IF THIS IS A TYPE 1 SVC
         BNZ   NONTYPE1           IF NOT, BRANCH TO SVRB PROCESSING
*                                 OTHERWISE, CONTINUE AS TYPE 1 SVC
*
* THIS IS WHERE WE INVOKE A TYPE 1 SVC ROUTINE, WHICH DOES NOT
* NEED A REQUEST BLOCK.
*
         CLI   TYP1FLAG,C'0'      CHECK SVC TYPE FLAG
         BNE   TYPERROR           IF ALREADY SET THEN THERE IS AN ERROR
         MVI   TYP1FLAG,C'1'      OTHERWISE, SET TYPE 1 FLAG TO 'YES'
*
         BALR  R14,R6             OTHERWISE, BR. TO SVC SLIH ITSELF
*
         CLI   TYP1FLAG,C'1'      CHECK SVC TYPE FLAG
         BNE   TYPERROR           IF ALREADY SET THEN THERE IS AN ERROR
         MVI   TYP1FLAG,C'0'      OTHERWISE, SET TYPE 1 FLAG TO 'NO'
*
         STM   R0,R1,TCBGRS       STORE RETURN VALUES R0 & R1 IN TCB
         ST    R15,TCBGRS+15*4    STORE RC IN REG 15 IN TCB AS WELL
         B     BRDISP
*
* THIS IS WHERE WE INVOKE A NON-TYPE 1 SVC ROUTINE. IT WILL RUN IN
* TASK STATE AND WILL REQUIRE SCHEDULING OF AN SVRB FOR IT TO BE
* PROPERLY DISPATCHED.
*
NONTYPE1 DS    0H
*
* OBTAIN AND INITIALIZE AN SVRB TO BECOME THE NEW CURRENT RB.
* SINCE THIS CODE WILL BE USED BY THE BRABEND ROUTINE AS WELL, VIA
* A DIRECT BRANCH, WE MUST RE-ESTABLISH ADDRESSABILITY HERE.
*
         BALR  R12,R0             USE THIS LOCATION AS THE NEW BASE
         USING *,R12
*
         GETCB100 WORKREG=8
         XC    0(RBLNTH,R10),0(R10) SET ENTIRE REQ. BLK TO ZEROS
         ST    R5,X'1C'(,R10)     STORE @ OF CURRENT RB IN NEW RBLINK
         ST    R10,TCBRB          SET THIS NEW RB AS THE CURRENT ONE
         LR    R5,R10
         MVC   RBTYPE(4),SVRBID   SET UP AN SVRB IDENTIFER STRING
         ST    R4,RBTCB           STORE @ OF TCB FOR THIS TASK IN RB
         MVC   RBGRSAVE(16*4),TCBGRS COPY REG VALUES FROM TCB SAVE
         MVC   RBFRSAVE(4*8),TCBFRS  COPY FLOATING REG VALUES INTO RB
*
         LA    R14,CVTEXIT        PUT @ OF SVC 3 INSTR. INTO R14
*
         STM   R0,R1,TCBGRS       STORE REG 1 AT PROPER PLACE IN TCB
         STM   R3,R6,TCBGRS+3*4   STORE STANDARD REGS IN TCB SAVE AREA
         STM   R13,R15,TCBGRS+13*4
*
         STCM  R6,B'0111',SVRBPSW+5 STORE @ OF SVC ROUTINE IN RB PSW
         MVC   RBOPSW(8),SVRBPSW  COPY THIS NEW PSW TO THE SVRB
*
* WHEN THE SVC RTN HAS COMPLETED PROCESSING, IT WILL RETURN HERE, AT
* WHICH TIME THE TASK WILL BE RE-DISPATCHED.
*
BRDISP   DS    0H
         L     R6,CVT0DS          OBTAIN @ OF CHAP FROM CVT
         BR    R6                 BRANCH TO CHAP
*
* THIS ERROR ROUTINE RECEIVES CONTROL WHEN THE INTERRUPT TYPE FLAG
* CONTAINS AN INVALID VALUE. THIS COULD BE INDICATIVE OF A LOGIC
* ERROR WITHIN THE OPERATING SYSTEM.
*
TYPERROR DS    0H
         XOPC  25                 ABEND WITH A DUMP
         DC    C'SVC TYPE FLAG INVALID'
*
* THIS ERROR ROUTINE RECEIVES CONTROL WHEN THE USER EITHER
* (1) REQUESTS A SVC WITH AN SVC # THAT IS OUT OF RANGE OF THE SVC
* TABLE, OR (2) REQUESTS AN UNSUPPORTED SVC NUMBER.
*
UNSVCHAN DS    0H
         XOPC  25                 ABEND WITH A DUMP
         DC    C'SVC # OUT OF RANGE OR NOT SUPPORTED'
*
* THIS ROUTINE RECEIVES CONTROL ONLY WHEN THE RB DOES NOT EXIST.
*
RBERROR  DS    0H
         XOPC  25                 ABEND WITH A DUMP
         DC    C'RB DOES NOT EXIST'
*
SVRBPSW  DC    XL8'FF0401190F000000'  PSW USED FOR SCHEDULING AN SVRB
SVRBID   DC    CL4'SVRB'              SVRB IDENTIFIER STRING
         DROP  R3,R4,R5,R12
         EJECT
*
*  U   U SSSSS EEEEE RRRRR   RRRRR EEEEE GGGGG IIIII OOOOO N   N SSSSS
*  U   U S     E     R   R   R   R E     G       I   O   O NN  N S
*  U   U SSSSS EEE   RRRRR   RRRRR EEE   G  GG   I   O   O N N N SSSSS
*  U   U     S E     R R     R R   E     G   G   I   O   O N  NN     S
*  UUUUU SSSSS EEEEE R  R    R  R  EEEEE GGGGG IIIII OOOOO N   N SSSSS
*
*
* THE FOLLOWING REGIONS OF STORAGE ARE USED FOR THE EXECUTION OF
* USER PROGRAMS. THERE ARE 4 REGIONS OF 4 KILOBYTES EACH.
*
         ORG   FIRST4K+X'A000'
REGIONA  DC    4096X'00'
REGIONB  DC    4096X'00'
REGIONC  DC    4096X'00'
REGIOND  DC    4096X'00'
         EJECT
*
*        >     N   N IIIII PPPPP    / M   M SSSSS     <
*         >    NN  N   I   P   P   /  MM MM S        <
*          >   N N N   I   PPPPP  /   M M M SSSSS   <
*         >    N  NN   I   P     /    M   M     S    <
*        >     N   N IIIII P    /     M   M SSSSS     <
*
*
* THIS SECTION OF CODE COMPRISES THE NUCLEUS INITIALIZATION PROGRAM.
* NIP WILL MAKE USE USE OF SVC 8 TO LOAD THE USER PROGRAM INTO THE
* BOTTOM (LOWEST ADDRESS) OF THE 4K USER AREA. NIP WILL SET UP
* REGISTERS TO POINT APPROPRIATELY FOR THE USE OF THE USER PROGRAM.
*
* UPON ENTRY TO NIP, THERE ARE NO REGISTER VALUE REQUIREMENTS. THE
* REGISTER USAGE WITHIN NIP IS AS FOLLOWS:
*
*   REG 0 = @ OF USER PROGRAM REGION TO BE USED (PASSED TO LOADER)
*   REG 1 = MAXIMUM SIZE OF OBJECT MODULE (BE PASSED TO LOADER)
*   REG 2 = USAGE NOT DEFINED
*   REG 3 = ADDRESS OF THE CVT (OBTAINED FROM BACKUP VALUE AT X'4C')
*   REG 4 = ADDRESS OF THE CURRENT TCB
*   REG 5 = ADDRESS OF THE RB POINTED TO BY THE CURRENT TCB
*   REG 6 = USAGE NOT DEFINED
*   REG 7 = USAGE NOT DEFINED
*   REG 8 = USAGE NOT DEFINED
*   REG 9 = USAGE NOT DEFINED
*   REG 10 = WORK REGISTER 1
*   REG 11 = USAGE NOT DEFINED
*   REG 12 = BASE REGISTER FOR NIP
*   REG 13 = POINTER TO THE FIRST REGISTER SAVE AREA IN USER CHAIN
*   REG 14 = RETURN ADDRESS FROM USER PGM (THE CVT EXIT: SVC 3)
*   REG 15 = LOADER RETURN CODE/ADDR. OF 1ST INSTRUCTION IN USER PGM
*
         ORG   FIRST4K+X'10000'
NIP      DS    0D
*
* FIRST WE SHOULD ESTABLISH ADDRESSIBILITY INTO OUR ESSENTIAL
* STRUCTURES.
*
         BALR  R12,R0             ESTABLISH A BASE REGISTER FOR NIP USE
         USING *,R12
*
* ESTABLISH POINTERS INTO OUR CVT, TCB AND RB.
*
         L     R3,X'4C'           OBTAIN ADDRESS OF THE CVT
         L     R4,0(,R3)          GET @ OF TCB WORDS
         L     R4,4(,R4)          OBTAIN ADDRESS OF CURRENT TCB
         L     R5,0(,R4)          OBTAIN ADDRESS OF CURRENT RB
         USING CVT,R3             AND ESTABLISH ADDRESSIBILITY
         USING TCB,R4
         USING RB,R5
*
* IF REG 5 CONTAINS ZERO THEN IT DOES NOT POINT TO A VALID RB, AND
* WE WILL ABEND ACCORDINGLY WITH A DUMP.
*
         LTR   R5,R5              IS THE REQUEST BLOCK @ INVALID?
         BZ    NIPNORB            IF SO THEN ABEND WITH A DUMP
*
* THIS IS WHERE WE LOAD OUR SVC 13 ABEND MODULE INTO MEMORY LOCATION
* X'7500' AND UPDATE THE SVC TABLE ACCORDINGLY.
*
         L     R6,CVTSVCTA        GET @ OF THE SVC TABLE
         LA    R7,13*8            GET OFFSET OF SVC 13 RTN IN SVC TABLE
         AR    R6,R7              POINT REG 6 TO SVC 13 ENTRY
         L     R8,0(,R6)          GET THE ENTRY ADDRESS FOR SVC 13
*
* IF REG 6 CONTAINS ZERO THEN THERE IS NO SVC 13 ABEND MODULE, AND
* WE WILL ABEND ACCORDINGLY WITH A DUMP.
*
         LTR   R8,R8              IS THE SVC 13 TABLE ENTRY NON-ZERO?
         BNZ   BADSVC13           IF SO, ABEND WITH A DUMP
*
* OTHERWISE, WE WILL LOAD THE NEW SVC 13 ABEND MODULE AT X'7500' AND
* UPDATE THE SVC TABLE PROPERLY.
*
         L     R0,SVC13LOC        REG 0 = @ AT WHICH TO LOAD SVC 13
         L     R1,SVC13SIZ        REG 1 = SIZE LIMIT FOR SVC 13 MODULE
         XOPC  4                  TURN OFF TRACE DURING LOAD PROCESS
         SVC   8                  INVOKE SVC 8 TO SVC 13 MODULE
         XOPC  2                  RE-ACTIVATE TRACE
         LTR   R15,15             TEST IF LOAD WAS SUCESSFUL
         BNZ   SVC13ERR           IF NOT, ABEND WITH A DUMP
*
         MVC   0(4,R6),SVC13LOC   STORE @ OF SVC 13 MODULE
         MVI   4(R6),X'C0'        SVC 13 IS TYPE 3 OR 4
         XC    5(3,R6),5(R6)      ZERO OUT THE REMAINING PART OF ENTRY
*
*
* WE WILL LOAD SOME PRE-DETERMINED VALUES INTO THE 4 FLOATING POINT
* REGISTERS FROM OUR STORAGE AREA.
*
         LE    0,FLOATER1         LOAD FLOATING POINTER VALUE 1
         LE    2,FLOATER2         LOAD FLOATING POINTER VALUE 2
         LE    4,FLOATER3         LOAD FLOATING POINTER VALUE 3
         LE    6,FLOATER4         LOAD FLOATING POINTER VALUE 4
*
* HERE WE WILL SET THE NIP/MS ECB TO X'7F',C'DSP'.
*
         MVC   MSECB(4),ECBDEFLT  SET DEFAULT NIP/MS ECB VALUE
         LA    R0,1               NUMBER OF ECBS TO BE WAITED ON
         LA    R1,MSECB           OBTAIN ADDRESS OF THE NIP/MS ECB
         ST    R1,CVTMSECB        STORE IT IN THE CVT
*
* THIS THE TOP OF THE MAIN NIP/MS LOOP. THE SVC 1 INSTRUCTION MAKES
* NIP/MS NON-DISPATCHABLE, MEANING THAT THE NEXT PROGRAM THAT WILL
* EXECUTE WILL BE THE ONE DEFINED BY THE USER PROGRAM TCB CREATED
* WITHIN THIS LOOP ITSELF.
*
NIPMS    DS    0H
         LA    R0,1               NUMBER OF ECBS TO BE WAITED ON
         LA    R1,MSECB           POINT REG 1 TO THE NIP/MS ECB
         SVC   1                  INVOKE THE WAIT SVC
*
         CLC   0(4,R1),ECBDEFLT   IS THE ECB VALUE X'7F',C'DSP'?
         BNE   ECBERROR           IF NOT THEN ABEND NIP/MS
*
* HERE IS WHERE WE DETERMINE WHETHER OR NOT THERE ARE MORE JOBS TO BE
* INITIALIZED. WE WILL CHECK (IN THE REGION TABLE) TO SEE IF THERE ARE
* MORE JOBS PENDING TO BE RUN, AND RUN THE CURRENT TCB CHAIN TO SEE
* IF ANY USER TCBS ARE STILL RUNNING. IF THERE ARE TCBS RUNNING, WE
* WILL SIMPLY BRANCH TO THE WAIT IN NIP/MS. WHEN THERE ARE NO MORE
* TCBS RUNNING, WE WILL WRITE OUT ACCOUNTING/TERMINATION MESSAGES FOR
* THE NIP/MS AND WAIT TCBS AND ABEND WITH A DUMP.
*
         L     R4,CVTHEAD         LOAD ADDRESS OF FIRST TCB IN CHAIN
         L     R5,0(,R4)          LOAD ADDRESS OF CURRENT RB FOR TCB
*
* NOW WE WILL RUN DOWN THE CHAIN OF TCBS AND FIND THE FIRST
* ONE THAT IS DISPATCHABLE. IF NONE ARE FOUND THEN WE WILL ABEND
* WITH A DUMP.
*
NIPRUN   DS    0H
         LTR   R4,R4              ARE WE AT THE END OF THE TCB CHAIN?
         BZ    NIPLOAD            IF SO THEN NO USER TCBS ARE RUNNING
*
         CLI   TCBLMP,X'F0'       IS THIS A USER TCB?
         BNE   ADVANCE            IF NOT THEN ADVANCE TO THE NEXT
*
         CLC   TCBTWAIT(4),NIPNONDS CHECK FOR THE 'NOTC' FLAG
         BNE   NIPWAIT              IF NOT THERE THEN TCB IS RUNNING
*
ADVANCE  DS    0H
         L     R4,TCBTCB          POINT TO NEXT TCB IN THE CHAIN
         L     R5,TCBRB           AND GET THE ADDRESS OF THE CURRENT RB
         B     NIPRUN             TEST THE NEXT TCB IN THE CHAIN
*
NIPLOAD  DS    0H
         L     R10,NEXTLOC        GET @ OF CURRENT REGION TABLE ENTRY
         L     R9,0(,R10)         GET REGION @ AT THAT LOCATION
         LTR   R9,R9              ARE THERE MORE PROGRAM TO BE RUN?
         BZ    SOSTERM            IF NOT THEN TERMINATE SOS-D
*
* CLEAR OUT THE NIP/MS TCB CHAINING POINTER.
*
         XC    LASTTCB(4),LASTTCB SET CHAINING FIELD TO ZEROS
         LA    R10,4              WE WILL CREATE 4 USER TCBS
*
* THE FOLLOWING LOOP IS USED TO CREATE A CHAIN OF USER PROGRAM, WHICH
* WILL BE EXECUTED SIMULTANEOUSLY. THE TCBS FOR EACH PROGRAM ARE
* CHAINED TOGETHER WITHIN THE LOOP, AND THE ENTIRE SET OF TCBS ARE
* ADDED TO THE CHAIN OF DISPATCHABLE TCBS AT THE BOTTOM.
*
* IF NO PROGRAMS ARE LEFT TO BE EXECUTED, WE WILL END WITH A DUMP.
*
* FIRST, WE MUST FIND AN UNUSED 4K REGION BY EXAMINING OUR TABLE OF
* USER REGION ADDRESSES. ALL USED REGIONS HAVE THEIR HIGHEST BIT SET.
*
USERLOOP DS    0H
         ST    R10,LOOPCTR        STORE NEW LOOP COUNTER
*
         L     R10,NEXTLOC        GET CURRENT POINTER INTO REGION TABLE
*
         L     R6,NEXTLOC         INCREMENT 4K REGION TABLE POINTER
         LA    R6,12(,R6)         TABLE ENTRY LENGTH IS 12 BYTES
         ST    R6,NEXTLOC         STORE POINTER TO THE NEXT ENTRY
*
* HAVING OBTAINED A 4K USER REGION ADDRESS FROM THE NIP TABLE,
* WE CAN NOW PROCEED TO PAD THE AREA WILL THE DESIGNATED FILL CHAR.
*
FILLAREA DS    0H
         ICM   R6,15,0(R10)       GET THE 4K REGION ADDRESS
         LTR   R6,R6              IF ADDRESS IS ZERO THEN ABEND
         BZ    NOMEMAVL
*
         LA    R8,4(,R10)         POINT TO THE PAD CHAR IN TABLE
*
         LA    R7,4095            FILL 4095 BYTES
         LA    R7,1(,R7)          THE SENDING FIELD IS ONE BYTE LONG
         LA    R9,1               THE SENDING FIELD IS ONE BYTE LONG
         ICM   R9,8,8(R10)        LOAD PAD CHAR IN LEFTMOST BYTE
*
         MVCL  R6,R8              PAD ENTIRE 4K REGION WITH FILL CHAR
*
* THE PIE, WHICH IS LOCATED AT THE TOP OF THE 4K USER REGION, MUST BE
* CLEARED OUT. THIS  WILL BE DONE HERE.
*
         ICM   R6,15,0(R10)       GET THE 4K REGION ADDRESS
         XC    4096-32(32,R6),4096-32(R6) ZERO OUT THE PIE
*
* FIRST, WE WILL ESTABLISH A JCL PARM LIST FOR THE USER PROGRAM.
* THIS GOES AT THE TOP OF THE 4K USER REGION. THE PARAMETER IS
* READ IN VIA SVC 0 AND MUST BE PARSED AND FORMATTED FOR THE
* USER PROGRAM.
*
         LA    R1,NIPIOB2         POINT TO READ I/O BLOCK
         SVC   0                  INVOKE SVC 0 TO READ JCL PARM
         LTR   R15,R15            WAS THE READ OPERATION A SUCCESS?
         BNZ   NOPARM             IF NOT THEN ABEND WITH A DUMP
*
* NOW WE WILL FIND THE "PARM=" KEYWORD IN THE JCL PARM CARD.
*
         LA    R6,JCLREC          START AT THE FIRST BYTE OF THE CARD
         LA    R7,76              SCAN ENTIRE RECORD
CHKKYWD  DS    0H
*        CLC   0(6,R6),PARMKW1    DID WE FIND THE ' PARM=' KEYWORD?
*        BE    SETPARM            IF SO THEN EXIT THE LOOP
         CLC   0(6,R6),PARMKW2    DID WE FIND THE ',PARM=' KEYWORD?
         BE    SETPARM            IF SO THEN EXIT THE LOOP
         LA    R6,1(,R6)          OTHERWISE, POINT TO THE NEXT POS.
         BCT   R7,CHKKYWD         AND BRANCH BACK TO TOP OF LOOP
*
* CONTROL COMES HERE WHEN NO JCL PARM KEYWORD WAS FOUND.
*
         XC    JCLPARM(2),JCLPARM SET THE JCL PARM LENGTH TO ZERO
         B     SETPARM            MOVE THE JCL PARM INFO TO 4K REGION
*
* HAVING FOUND A VALID PARM KEYWORD, THIS IS WHERE WE FORMAT THE
* VALUE OF THE PARM ITSELF SO THAT IT MAY BE USED IN THE USER'S
* PROGRAM. THE PARM MAY IN ANY OF THE FOLLOWING THREE FORMS:
*
*          PARM=
*          PARM=ISAAC
*          PARM='ISSAC NEWTON'
*
* HENCE, WE MUST ACCOUNT FOR EACH POSSIBLE CASE.
*
*
* WE ARE NOW READY TO MOVE THE REFORMATTED JCL PARM TO THE TOP
* OF THE USER'S 4K REGION, JUST BELOW THE PIE. THE PARM ITSELF
* WILL BE PADDED WITH X'00' AT THE END IF IT IS OF AN ODD LENGTH.
*
SETPARM  DS    0H
         XC    NIPTRT(256),NIPTRT CLEAR OUT THE TRT SCAN TABLE
         LA    R6,6(,R6)          POINT TO FIRST CHARACTER OF PARM
         CLI   0(R6),C''''        IS THE FIRST CHARACTER AN APOST?
         BNE   NOAPOST            IF NOT, PARM IS ONLY ONE WORD LONG
*
         MVI   NIPTRT+C'''',X'FF' OTHERWISE, WE WILL SCAN FOR NEXT ONE
         LA    R6,1(,R6)          START OF PARM IS ACTUALLY NEXT BYTE
         B     SCANEND            SCAN FOR THE END OF THE PARM
*
NOAPOST  DS    0H
         MVI   NIPTRT+C' ',X'FF'  OTHERWISE, WE WILL SCAN FOR NEXT ONE
         MVI   NIPTRT,X'FF'
*
SCANEND  DS    0H
         LA    R7,JCLREC+80       FIND NUMBER OF BYTES TO SCAN (THIS
         SR    R7,R6              THE NUMBER REMAINING ON THE CARD)
         EX    R7,SCANPARM        SCAN FOR END-OF-PARM CHARACTER
         LR    R7,R1              COMPUTE LENGTH OF THE PARM
         SR    R7,R6
*
* HAVING FOUND THE LENGTH AND LOCATION OF THE JCL PARM, WE CAN NOW
* MOVE IT INTO THE 4K REGION, JUST BELOW THE 32-BYTE PIE.
*
         ICM   R15,15,0(R10)      SET R15 TO START OF 4K REGION
         LA    R15,4095-32(,R15)  FIND HIGH WALL OF PARM AREA
         LA    R8,1(,R7)          ROUND PARM LENGTH TO NEXT HALFWORD
         N     R8,JCLMASK
*
         MVI   0(R15),X'00'       SET PAD CHAR FOR ODD LENGTHED PARMS
         SR    R15,R8             FIND PLACE WHERE PARM WILL GO
         LA    R15,1(,R15)
*
         LTR   R7,R7              IS THE PARM LENGTH EQUAL TO 0?
         BZ    PUTLEN             IF SO THEN SKIP THIS PART
         BCTR  R7,R0              ADJUST FOR TRAILING BLANK OR "'"
         EX    R7,MOVEPARM        MOVE PARM FROM INPUT CARD TO REGION
         LA    R7,1(,R7)          RESTORE ACTUAL LENGTH OF PARM
*
PUTLEN   DS    0H
         BCTR  R15,R0             OBTAIN ADDRESS OF LENGTH HALFWORD
         BCTR  R15,R0
*
         LR    R9,R15             PLACE PAD CHARS IN FRONT OF LENGTH
         N     R9,JCLMASK2        ROUND TO A FULLWORD BOUNDARY
         MVI   0(R9),X'00'
         MVI   1(R9),X'00'
         STH   R7,0(,R15)         STORE THE LENGTH OF THE PARM
*
         LR    R1,R15             POINT REG 1 TO PARM LIST
         O     R15,JCLMASK4       SET HIGH BIT OF PARM POINTER
         BCTR  R1,R0              POINT INTO THE PREV FULLWORD IN
         BCTR  R1,R0              STORAGE
         BCTR  R1,R0
         BCTR  R1,R0
         N     R1,JCLMASK2        ROUND TO A FULLWORD BOUNDARY
         ST    R15,0(,R1)         STORE THE ADDRESS OF THE JCL PARM
*
* NOW WE WILL ESTABLISH THE REGISTER SAVE AREA JUST BELOW THE
* JCL PARAMETER LIST. THE BACKWARD POINTER WILL BE SET TO ZERO TO
* INDICATE THAT THIS IS THE START OF THE SAVE AREA CHAIN.
*
         LR    R13,R1             OBTAIN ADDRESS OF JCL PARM LIST
         LA    R11,72             COMPUTE ADDRESS OF SAVE AREA
         SR    R13,R11
         MVI   0(R13),X'FF'       FILL SAVE AREA WITH -1'S
         MVC   1(71,R13),0(R13)
         XC    1*4(4,R13),1*4(R13) SET BACKWARD POINTER TO ZERO
*
* FINALLY, WE WILL SET UP A 256 BYTE WORK AREA JUST BELOW THE 18F REG
* SAVE AREA. THIS WORK AREA WILL BE USED BY SVC 13 TO STORE ABEND
* INFO FOR THE PROGRAM (IF IT DOES NOT ABEND). THIS IS DONE SOLEY TO
* ACCOMODATE A NEWLY REENTRANT VERSION OF SVC 13, WHICH IS ASSEMBLED
* SEPERATELY.
*
         LA    R7,256             SET ASIDE 256 BYTES FOR SVC 13
         LR    R8,R13             PUT WORK AREA JUST BELOW 18F SAVEAREA
         SR    R8,R7
         N     R8,JCLMASK3        ROUND ADDRESS TO DOUBLEWORD BOUNDARY
         ST    R8,SVC13WK         STORE @ OF WORK AREA FOR LATER
*
* NOW WE MUST OBTAIN AND INITIALIZE A TCB AND RB, UNDER WHICH THE
* USER PROGRAM WILL RUN.
*
         GETCB100 CBREG=R4
         USING TCB,R4             ESTAB. ADDRESSIBILITY INTO TCB DSECT
         XC    TCB(TCBLNTH),TCB   SET ENTIRE TCB TO HEX ZEROS
*
         GETCB100 CBREG=R5
         USING RB,R5              ESTAB. ADDRESSIBILITY INTO RB DSECT
         XC    RB(RBLNTH),RB      SET ENTIRE RB TO HEX ZEROS
*
* NOW WE CAN INITIALIZE OUR TASK CONTROL BLOCK AND OUR REQUEST BLOCK.
* THIS TCB AND RB WILL BE USED TO THE USER PROGRAM. FOR RIGHT NOW, IT
* WILL BE SET AS NON-DISPATCHABLE.
*
         LR    R0,R4              SAVE ADDRESS OF THIS TCB FOR CHAINING
         ST    R4,4(,R10)         STORE ADDRESS OF TCB IN TABLE
*
         MVC   TCBBACK(4),LASTTCB SET CHAIN LINK TO PREVIOUS TCB
*
         L     R11,LASTTCB        GET @ OF LAST USER TCB CREATED
         LTR   R11,R11            IS THIS THE FIRST USER TCB?
         BZ    STORERB            IF SO THEN SKIP TCB CHAINING
*
         L     R4,LASTTCB         ADDRESS PREVIOUS TCB IN CHAIN
         ST    R0,TCBTCB          CHAIN TO THE NEW TCB
*        LR    R4,R6              ADDRESS THE WAIT TCB
*        ST    R0,TCBBACK         SET BACKWARD LINK TO THE NEW TCB
         LR    R4,R0              REGAIN ADDRESSABILITY INTO NEW TCB
*
STORERB  DS    0H
         ST    R5,TCBRB           STORE @ OF TCB REQ. BLK
         STCM  R4,7,RBLINK+1      THIS IS THE ONLY RB FOR NOW
         OI    RBFLGS3,X'80'      SET HIGH BIT OF RBLINK FIELD
*
         MVC   RBTYPE(4),PGMRBID    SET REQUEST BLOCK TYPE CODE = 'PRB'
         MVC   TCBIDENT(4),PGMTCBID SET TCB IDENTIFIER STRING
*
         MVI   TCBDSP,X'F0'         SET USER PGM DISPATCH PRIORITY
         MVI   TCBLMP,X'F0'         SET USER PGM PRIORITY LIMIT
*
         MVC   TCBTNAME(8),PGMTCBNM SET USER TCB IDENTIFIER
         MVC   TCBTNAME+3(1),8(R10)
         MVC   TCBTNAME+4(4),TCBTNAME+3
         ST    R4,RBTCB           STORE @ OF TCB FOR THIS TASK
*
* NOW WE WILL STORE THE VALUES IN REGS 1 & 13, AS WELL AS THE
* FLOATING POINT REGISTERS, INTO THE TCB AREAS. THESE VALUES WILL BE
* PASSED TO THE USER PROGRAM WHEN IT IS DISPATCHED.
*
         ST    R1,TCBGRS+1*4      STORE POINTER TO PARMLIST
         ST    R1,TCBAPARM        STORE POINTER TO PARMLIST
         ST    R13,TCBGRS+13*4    STORE POINTER TO REG SAVE AREA
         ST    R13,TCBFSA         STORE START OF SAVE AREA CHAIN
         LA    R14,CVTEXIT        GET ADDRESS OF SVC EXIT INSTRUCTION
         ST    R14,TCBGRS+14*4    STORE CVT EXIT @ IN THE TCB
         ICM   R6,15,0(R10)       OBTAIN @ OF START OF A 4K USER REGION
         LA    R6,4096-32(,R6)    GET ADDRESS OF THE PIE
         ST    R6,TCBAPIE         STORE IT IN THE TCB
*
         MVC   TCBAWORK(4),SVC13WK STORE @ OF 256 BYTE WORK AREA
*
         STD   R0,TCBFRS          STORE FLOATING POINT VALUES
         STD   R2,TCBFRS+1*8
         STD   R4,TCBFRS+2*8
         STD   R6,TCBFRS+3*8
*
* NOW WE WILL ATTEMPT TO LOAD THE USER PROGRAM INTO ONE OF THE 4K
* USER REGIONS. THE LOADER IS ACCESSED THROUGH SVC 8, AND IS PASSED
* THE FOLLOWING INFORMATION:
*
*   REG 1 = ADDRESS OF LOCATION IN WHICH TO LOAD THE OBJECT MODULE
*   REG 2 = MAXIMUM SIZE OF THE OBJECT MODULE. THE USER REGION IS
*           4,096 BYTES. HOWEVER, WE MUST ALSO ACCOMMODATE A 72 BYTE
*           SAVE AREA, 32 BYTE PIE, AND A JCL PARM AREA OF UNDETERMINED
*           LENGTH.
*
* UPON A SUCCESSFUL LOAD OPERATION, REG 15 CONTAINS A ZERO.
*
         ICM   R0,15,0(R10)       OBTAIN @ OF START OF A 4K USER REGION
         OI    0(R10),X'80'       SET THE HIGH BIT IN THE
*                                 TABLE ENTRY TO INDICATE THAT THIS
*                                 4K REGION IS BEING USED.
*
         L     R1,SVC13WK         COMPUTE TOTAL AVAILABLE SPACE
         SR    R1,R0              CONSIDER THE JCL PARM, PIE, REGSAVE,
*                                 AND THE 256 BYTE WORK AREA
         XOPC  4                  TURN OFF TRACE DURING LOAD PROCESS
         SVC   8                  INVOKE SVC 8 TO LOAD USER PROGRAM
         XOPC  2                  RE-ACTIVATE TRACE
         LTR   R15,15             TEST IF LOAD WAS SUCESSFUL
         BNZ   LOADERR            IF NOT, ABEND WITH A DUMP
*
         ST    R0,TCBGRS+15*4     STORE PGM ENTRY POINT IN TCB
*
* NOW THAT THE USER PROGRAM HAS BEEN LOADED, IT IS TIME TO FINISH
* SETTING UP THE TCB FOR THE USER PROGRAM. WE MUST FORM A PSW AND
* SET THE PROPER PROTECTION KEY.
*
         MVC   RBOPSW(8),USERPSW  COPY A PSW INTO THE USER PGM RB
         OC    RBOPSW+1(1),5(R10) GET THE PROTECTION KEY FOR REGION
         STCM  R0,7,RBOPSW+5      STORE PGM ENTRY ADDRESS IN RB PSW
*
* NOW WE MUST SET THE APPROPRIATE STORAGE KEY FOR THE REGION. THIS
* KEY WILL MATCH THE ONE THAT WAS JUST PLACED IN THE RB PSW.
*
         ICM   R6,1,9(R10)        GET PROTECTION KEY FROM THE TABLE
         L     R7,0(,R10)         OBTAIN @ OF FIRST 2K BLOCK IN REGION
         SSK   R6,R7              SET THE STORAGE KEY FOR THE 2K BLOCK
         LA    R7,2048(,R7)       POINT TO THE NEXT 2K BLOCK
         SSK   R6,R7              SET THE STORAGE KEY FOR THE 2K BLOCK
*
* NOW WE WILL SET UP A MESSAGE TO INDICATE THE SUCCESSFUL LOADING
* OF THE USER PROGRAM. THIS MESSAGE WILL INDICATE THE NAME OF THE
* PROGRAM, THE LOCATION AT WHICH IT WAS LOADED, AND ITS LENGTH.
*
         LR    R11,R0             MOVE PROGRAM LOAD @ TO SAFE PLACE
         MVC   NIPMSG1+36(8),5(R11) MOVE THE PROGRAM NAME TO MSG AREA
         MVC   TCBPNAME(8),5(R11)   MOVE THE PROGRAM NAME TO THE TCB
*
         LA    R2,NIPTRAN         GET ADDRESS OF TRANSLATE TABLE
         LA    R10,240            ADJUST FOR CONDENSED TABLE
         SR    R2,R10
*
         ST    R0,NIPWORK1        CHANGE PGM ENTRY POINT TO PRINTABLE
         UNPK  NIPWORK2(9),NIPWORK1(5)
         TR    NIPWORK2(8),0(R2)
         MVC   NIPMSG1+86(6),NIPWORK2+2
*
         ST    R1,NIPWORK1        CHANGE PGM LENGTH TO PRINTABLE FORM
         UNPK  NIPWORK2(9),NIPWORK1(5)
         TR    NIPWORK2(8),0(R2)
         MVC   NIPMSG1+109(6),NIPWORK2+2
*
* NOW WE WILL ISSUE A SET OF MESSAGES TO INDICATE (1) THAT EXECUTION
* OF THE USER PROGRAM IS ABOUT TO BEGIN, (2) THE ENTRY POINT ADDRESS
* OF THE USER MODULE, AND (3) THE TOTAL LENGTH OF THE PROGRAM.
*
* WE WILL PRINT THESE MESSAGES USING SVC 0. THUS, WE MUST SET UP AN
* I/O BLOCK FOR EACH MESSAGE. (THE SAME I/O BLOCK IS USED FOR EACH
* MESSAGE, WITH THE MESSAGE ADDRESS FIELD SET TO POINT TO THE PROPER
* MESSAGE TO BE PRINTED).
*
         MVI   NIPMSGLN,C' '      CLEAR OUT THE MESSAGE AREA
         MVC   NIPMSGLN+1(79),NIPMSGLN
*
         MVC   NIPMSGLN(133),NIPMSG1 MOVE IN THE FIRST MESSAGE
         BAL   R10,NIPSVC0           PRINT OUT THE FIRST MESSAGE
*
* NOW WE CAN BRANCH BACK UP TO THE TOP OF THE NIP/MS LOOP. THE SVC 0
* INSTRUCTION AT THE TOP OF THE LOOP WILL CAUSE THE DISPATCHER TO
* PASS CONTROL TO THE USER TCB.
*
         ST    R4,LASTTCB         STORE @ OF LAST USER TCB CREATED
         L     R10,LOOPCTR        LOAD THE LOOP COUNTER VALUE
         BCT   R10,USERLOOP       BRANCH BACK IF MORE JOBS ARE LEFT
*
* NOW WE CAN CONNECT THE SET OF USER JOB TCBS TO THE ACTIVE CHAIN
* OF DISPATCHABLE TASKS.
*
* WE WILL RUN DOWN THE CHAIN OF TCBS AND FIND THE LAST TCB ON
* THE CHAIN, WHICH SHOULD BE THE WAIT TCB. THE TCB FOR THE USER PROGRAM
* WILL BE CHAINED JUST ABOVE THE WAIT TCB.
*
         L     R4,CVTHEAD         GET @ OF FIRST TCB IN THE CHAIN
FINDWAIT DS    0H
         LR    R7,R6              OBTAIN ADDRESS OF TCB JUST ABOVE WAIT
         LR    R6,R4              SET REG 6 TO POINT TO WAIT TCB
         L     R4,TCBTCB          POINT TO NEXT TCB IN THE CHAIN
         LTR   R4,R4              IS THIS LINK FIELD ZERO?
         BNZ   FINDWAIT           IF NOT THEN GO TO THE NEXT TCB
*
         LR    R4,R6              GET ADRESSABILITY INTO WAIT TCB
         MVC   TCBBACK(4),LASTTCB SET BACKWARD LINK OF WAIT TCB
         LR    R4,R7              GET ADDRESSABILITY INTO PREVIOUS TCB
         MVC   TCBTCB(4),MEMTBL+4 INSERT SUB-CHAIN INTO ACTIVE CHAIN
         L     R4,LASTTCB         GET ADDRESSABILITY INTO NEWEST TCB
         ST    R6,TCBTCB          SET FORWARD LINK TO WAIT TCB
*
         L     R4,CVTHEAD         GET @ OF FIRST TCB IN THE CHAIN
         L     R4,TCBTCB          GET ADDRESS OF 1ST USER TCB
         MVC   TCBBACK(4),CVTHEAD SET BACKWARD PTR TO MAST. SCH. TCB
*
NIPWAIT  DS    0H
         XC    MSECB(4),MSECB     CLEAR OUT THE NIP/MS ECB
         B     NIPMS
*
* THIS SMALL SUBROUTINE IS USED TO PRINT OUT A MESSAGE LINE.
* UPON ENTRY, REG 10 SHOULD CONTAIN THE RETURN ADDRESS.
*
NIPSVC0  DS    0H
         XOPC  4                  TURN OF TRACE TEMPORARILY
         LA    R1,NIPIOB1         POINT TO MESSAGE I/O BLOCK FOR SVC 0
         SVC   0                  ISSUE SVC TO PERFORM THE I/O
         LTR   R15,R15            WAS THE I/O SUCCESSFUL?
         BNZ   BADIOB             IF NOT THEN ABEND WITH A DUMP
         XOPC  2                  TURN TRACE BACK ON WITH PREV. PARMS
         BR    R10                RETURN TO THE MAIN PROGRAM BODY
*
* THIS SECTION OF CODE RECEIVES CONTROL WHEN THERE ARE NO MORE USER
* TASKS RUNNING, AND THERE ARE NO MORE TO BE LOADED AND RUN. AN
* ACCOUNTING/TERMINATION LINE IS PRINTED OUT FOR BOTH THE NIP/MS AND
* WAIT TCBS, BEFORE ENDING SOS-D WITH AN XOPC 25.
*
SOSTERM  DS    0H
         LR    R0,R12             SAVE VALUE OF OUR BASE REGISTER
*
         L     R4,CVTHEAD         GET @ OF NIP/MS TCB
         LA    R2,15              SEND NIP/MS AND WAIT TCB STATS TO 'F'
         L     R12,CVTSUB1        GET ADDRESS OF 'JOB END' MSG SUBRTN
         BALR  R14,R12            PRINT THE JOB END INFORMATION
         LR    R12,R0             REGAIN ADDRESSABILITY INTO NIP/MS
*
SCANWAIT DS    0H
         L     R4,TCBTCB          GET ADDRESS OF THE WAIT TCB
         LTR   R4,R4              IS THE TCB ADDRESS ZERO?
         BZ    WAITNOT            IF SO THEN THERE IS NO WAIT TCB!
*
         CLC   WAITMARK(8),TCBTNAME IS THIS THE WAIT TCB?
         BNE   SCANWAIT             IF NOT THEN LOOK AT THE NEXT ONE
*
         L     R12,CVTSUB1        GET ADDRESS OF 'JOB END' MSG SUBRTN
         BALR  R14,R12            PRINT THE JOB END INFORMATION
         LR    R12,R0             REGAIN ADDRESSABILITY INTO NIP/MS
*
         XOPC  25                 TERMINATE SOS-D WITH A DUMP
         DC    C'SOS-D HAS TERMINATED NORMALLY!!!'
*
* THIS PORTION OF CODE RECIEVES CONTROL ONLY IF THE ECB FOR NIP/MS
* DOES NOT CONTAIN THE PROPER VALUE AFTER THE EXECUTION OF THE WAIT SVC
* AT THE TOP OF NIP/MS.
*
ECBERROR DS    0H
         XOPC  25
         DC    C'NIP/MS ECB VALUE INCORRECT'
*
* CONTROL COMES HERE ONLY WHEN THERE WAS AN ERROR LOADING THE
* USER PROGRAM.
*
LOADERR  DS    0H
         XOPC  25                 OTHERWISE, ABEND WITH A DUMP
         DC    C'USER PROGRAM NOT LOADED'
*
* CONTROL COMES HERE ONLY WHEN THE REQUEST BLOCK ADDRESS IS ZERO.
*
NIPNORB  DS    0H
         XOPC  25
         DC    C'NO REQUEST BLOCK FOR THE CURRENT TCB'
*
* THIS PORTION OF CODE IS EXECUTED ONLY IF THERE ARE NO AVAILABLE
* 4K USER REGIONS IN WHICH TO RUN THE USER PROGRAM.
*
NOMEMAVL DS    0H
         XOPC  25
         DC    C'HIT END OF USER REGION TABLE'
*
* THIS PORTION OF CODE GETS CONTROL ONLY WHEN THERE IS AN ERROR READING
* THE JCL PARM CARD.
*
NOPARM   DS    0H
         XOPC  25
         DC    C'ERROR READING JCL PARM CARD'
*
* THIS SECTION OF CODE IS EXECUTED ONLY WHEN SVC 0 ENCOUNTERS AN
* INVALID IOB ON AN I/O OPERATION.
*
BADIOB   DS    0H
         XOPC  25
         DC    C'BAD IOB IN MS/NIP'
*
* THIS SECTION OF CODE HANDLES THE CASE WHERE THE SVC TABLE ALREADY
* HAS AN ENTRY FOR SVC 13, EVEN THOUGH THE SVC 13 MODULE HAS NO YET
* BEEN LOADED.
*
BADSVC13 DS    0H
         XOPC  25
         DC    C'NON-ZERO SVC 13 ENTRY BEFORE SVC 13 MODULE LOADED'
*
* THIS SECTION OF CODE IS INVOKED WHEN THERE IS AN ERROR LOADING THE
* SVC 13 "ABEND" MODULE.
*
SVC13ERR DS    0H
         XOPC  25
         DC    C'ERROR LOADING SVC 13 MODULE'
*
* THIS SECTION OF CODE IS INVOKED WHEN NIP/MS CANNOT FIND THE WAIT TCB.
*
WAITNOT  DS    0H
         XOPC  25
         DC    C'CANNOT FIND WAIT TCB'
*
         EJECT
******
*
* STORAGE AREA FOR NIP/MS.
*
******
LOOPCTR  DC    A(0)               NUMBER OF JOBS LEFT TO BE INTIALIZED
LASTTCB  DC    A(0)               @ OF LAST TCB CREATED BY NIP/MS
NEXTLOC  DC    A(MEMTBL)          ADDR OF NEXT UNUSED ENTRY IN TABLE
*
* EACH ENTRY IN THE REGION TABLE IS 12 BYTES LONG. SOME OF THE BYTES
* ARE NOT USED, AS THEY ARE SIMPLY SLACK BYTES. THE FORMAT OF EACH
* ENTRY IN THE USER REGION TABLE IS AS FOLLOWS:
*
*       ENTRY+0 ==> A(AVAILABLE 4K REGION)
*       ENTRY+4 ==> A(TCB CREATED FOR THIS JOB)
*       ENTRY+8 ==> FILLER CHARACTER FOR THE 4K USER EGION
*       ENTRY+9 ==> PSW STORAGE KEY FOR THE 4K USER REGION
*
MEMTBL   DC    A(REGIONA),A(0),C'A',X'A0'
         DC    A(REGIONB),A(0),C'B',X'B0'
         DC    A(REGIONC),A(0),C'C',X'C0'
         DC    A(REGIOND),A(0),C'D',X'D0'
         DC    A(0)               END OF USER ADDRESS SPACE TABLE
*
* THESE ITEMS ARE USED IN THE INITIALIZATION OF THE USER JOB'S TCB
* AND RB FIELDS.
*
         DS    0D
USERPSW  DC    X'FF0501190F',AL3(0)
PGMRBID  DC    CL4'PRB '          REQUEST BLOCK IDENTIFIER STRING
PGMTCBID DC    CL4'TCB '          TCB IDENTIFIER STRING
PGMTCBNM DC    CL8'TCB     '
WAITMARK DC    CL8'TCBWAIT '      WAIT TCB IDENTIFIER
*
* THESE FIELDS ARE USED IN CONVERTING HEXADECIMAL VALUES IN PRINTABLE
* FORMAT.
*
NIPWORK1 DC    F'0',CL1' '        WORK FIELD FOR PRINTING REG CONTENTS
NIPWORK2 DC    CL9' '
NIPTRAN  DC    C'0123456789ABCDEF'
NIPTRT   DC    XL256'00'
*
* THESE VALUES ARE USED FOR LOADING IN THE SVC 13 ABEND MODULE.
*
SVC13WK  DC    A(0)               ADDRESS OF SVC 13 WORK AREA IN REGION
SVC13LOC DC    XL4'7500'          ADDRESS OF WHERE TO LOAD SVC 13 CODE
SVC13SIZ DC    XL4'0400'          SIZE LIMIT FOR SVC 13 MODULE
*
* THIS IS THE EVENT CONTROL BLOCK FOR NIP/MS.
*
MSECB    DC    F'0'               NIP/MS EVENT CONTROL BLOCK
ECBDEFLT DC    X'7F',C'DSP'       INITIAL VALUE FOR THE ECB
*
* THIS I/O BLOCK IS USED FOR ISSUING MESSAGES VIA SVC 0
*
NIPIOB1  DS    0F
         DC    CL4'IOB '          I/O BLOCK IDENTIFIER
         DC    X'000E'            SEND NIP MESSAGES TO VIRT PRINT 1
         DC    X'01AA'            MESSAGE PRINT REQUEST
MSGADDR  DC    A(NIPMSGLN)        ADDRESS OF MESSAGE TO BE PRINTED
         DC    H'133'             LENGTH OF EACH MESSAGE IS 133 BYTES
NIPMSGLN DC    CL133' '           MESSAGE OUTPUT LINE
*
* THIS I/O BLOCK IS USED FOR READING IN THE JCL PARAMETERS VIA SVC 0.
* THESE PARAMETERS ARE PASSED TO EACH USER PROGRAM.
*
NIPIOB2  DS    0F
         DC    CL4'IOB '          I/O BLOCK IDENTIFIER
         DC    X'000D'            READ JCL PARMS FROM DEVICE AT X'00D'
         DC    X'02AA'            READ REQUEST
         DC    A(JCLREC)          ADDRESS OF INPUT RECORD BUFFER
         DC    H'80'              THE INPUT BUFFER IS 80 BYTES LONG
*
* THIS IS THE INPUT BUFFER USED IN READING JCL PARMS VIA SVC 0.
*
JCLPARM  DC    H'11',CL11'JOE KESSLER'
JCLREC   DC    CL81' '
JCLMASK  DC    0F'0',X'FFFFFFFE'  USED FOR ROUNDING HALFWORD ADDRESSES
JCLMASK2 DC    0F'0',X'FFFFFFFC'  USED FOR ROUNDING FULLWORD ADDRESSES
JCLMASK3 DC    0F'0',X'FFFFFFF8'  USED FOR ROUNDIND D.W. ADDRESSES
JCLMASK4 DC    0F'0',X'80000000'  USED TO SET HIGH BIT OF PLIST ITEM
MOVEPARM MVC   0(0,R15),0(R6)     MVC TO MOVE JCL PARM TO USER REGION
SCANPARM TRT   0(0,R6),NIPTRT     USED TO FIND END OF JCL PARM
PARMKW1  DC    CL6' PARM='
PARMKW2  DC    CL6',PARM='
*
NIPNONDS DC    CL4'NOTC'          TCB NON-DISPATCHABILITY FLAG VALUE
*
* FLOATING POINT REGISTER DEFAULT VALUES.
*
         DS    0F
FLOATER1 DC    X'C3100200'
FLOATER2 DC    X'43102000'
FLOATER3 DC    X'C2120000'
FLOATER4 DC    X'41200000'
*
NIPMSG1  DC CL133' *** JAK SOS-D HAS PREPARED MODULE ''        '' FOR EX
               XECUTION  ::  PROGRAM ENTRY POINT:          TOTAL LENGTHX
               :        BYTES'
         EJECT
*
* >    DDDD  IIIII SSSSS PPPPP   A   TTTTT CCCCC H   H EEEEE RRRRR    <
*  >   D   D   I   S     P   P  A A    T   C     H   H E     R   R   <
*   >  D   D   I   SSSSS PPPPP A   A   T   C     HHHHH EEE   RRRRR  <
*  >   D   D   I       S P     AAAAA   T   C     H   H E     R R     <
* >    DDDD  IIIII SSSSS P     A   A   T   CCCCC H   H EEEEE R  R     <
*
*
* THE FOLLOWING SECTION OF CODE COMPRISES THE DISPATCHER. THE
* DISPATCHER HAS THREE FUNCTIONS TO PERFORM. THEY ARE AS FOLLOWS:
*
*      (1) TO MOVE THE PSW TO BE DISPATCHED FROM RBPSW TO A LOWCCORE
*          LOCATION,
*      (2) LOAD ALL REGISTERS FROM TCBREGS, AND
*      (3) PERFORM AN LPSW USING THE PSW PREVIOUSLY RELOCATED TO THE
*          LOWCORE LOCATION.
*
* UPON ENTRY TO THE DISPATCHER, THE FOLLOWING REGISTER CONVENTIONS
* MUST BE OBSERVED:
*
*  R3 = @ OF THE CVT
*  R4 = @ OF TCB TO BE DISPATCHED
*  R5 = @ OF THE RB TO BE DISPATCHED
*  R6 = @ OF THE DISPATCHER (THIS MODULE)
*
         ORG   FIRST4K+X'11800'
DISPATCH DS    0D
*
* NOW WE CAN ESTABLISH ADDRESSIBILITY FOR EACH OF THE ITEMS PASSED TO
* THE DISPATCHER MODULE.
*
         USING DISPATCH,R6        ESTABLISH ADDRESSIBILITY FOR THIS PGM
         USING CVT,R3             ESTABLISH ADDRESSIBILITY INTO CVT
*
         STM   R0,R15,DISPSAVE    SAVE INITIAL REGISTERS FOR DEBUGGING
*
REDISP   DS    0H
         L     R4,CVTHEAD         LOAD ADDRESS OF FIRST TCB IN CHAIN
         L     R5,0(,R4)          LOAD ADDRESS OF CURRENT RB FOR TCB
         USING TCB,R4             ESTABLISH ADDRESSIBILITY INTO TCB
         USING RB,R5              ESTABLISH ADDRESSIBILITY INTO RB
*
* NOW WE WILL RUN DOWN THE CHAIN OF TCBS AND FIND THE FIRST
* ONE THAT IS DISPATCHABLE. IF NONE ARE FOUND THEN WE WILL ABEND
* WITH A DUMP.
*
RUNCHAIN DS    0H
         LTR   R4,R4              TEST FOR EXISTENCE OF A TCB
         BZ    NOTCBS             IF NOT A VALID TCB @ THEN ABEND
*
         CLC   TCBTWAIT(4),TCBDONE CHECK FOR THE 'NOTC' FLAG
         BE    NEXTTASK            IF FOUND THEN IGNORE THIS TCB
*
         LTR   R5,R5              TEST FOR RB EXISTENCE
         BZ    NOREQBLK           IF IT EXISTS THEN CONTINUE
*
         CLI   RBWCF,X'00'        EXAMINE RB WAIT COUNT FIELD
         BZ    RUNIT              IF IT CONTAINS ZERO, DISPATCH THIS RB
*
NEXTTASK DS    0H
         L     R4,TCBTCB          POINT TO NEXT TCB IN THE CHAIN
         L     R5,TCBRB           AND GET THE ADDRESS OF THE CURRENT RB
         B     RUNCHAIN           TEST THE NEXT TCB IN THE CHAIN
*
* HAVING FOUND A DISPATCHABLE TCB, WE CAN NOW TRANSFER CONTROL TO IT.
*
RUNIT    DS    0H
         L     R8,0(,R3)          OBTAIN ADDRESS OF TCB WORDS
         ST    R4,4(,R8)          STORE @ OF NEW TCB IN TCB WORDS
*
* THIS IS WHERE WE UPDATE THE APPROPRIATE TIME FIELDS IN THE TCB. WE
* WILL SET THE TCBTDISP AND (POSSIBLY, IF THIS IS THE FIRST DISPATCH
* OF THE JOB) THE TCBTWALS FIELDS.
*
         MVC   TCBTDISP(4),X'50'     SAVE THE CURRENT TIMER VALUE
*
         CLC   TCBTWALS(4),ZEROTIME  FIRST TIME THIS JOB DISPATCHED?
         BNE   ADDSYSTM              IF NOT THEN DON'T STORE TCBTWALS
         MVC   TCBTWALS(4),TCBTDISP  OTHERWISE, STORE TIME OF FIRST
*                                    DISPATCH FOR THIS TASK
*
* NOW WE WILL RESTORE THE USER'S GENERAL PURPOSE AND FLOATING
* POINT REGISTERS, AND START COUNTING EXECUTION TIME ONCE AGAIN.
*
ADDSYSTM DS    0H
*
* NOW WE WILL COMPUTE THE SYSTEM TIME ELAPSED SINCE THE LAST INTERRUPT
* OCCURRED, AND ADD IT TO THE TOTAL IN TCBTSYS.
*
         L     R8,LOWTIME         GET CPU TIME AT DISPATCH
         S     R8,TCBTDISP        SUBTRACT CPU TIME AT SVC INTERRUPT
         A     R8,TCBTSYS         ADD ELAPSED SYSTEM TIME
         ST    R8,TCBTSYS         STORE IT BACK INTO THE TCB FIELD
*
* FINALLY, WE ARE READY TO TRANSFER CONTROL TO THE TASK.
*
         MVC   LOWPSW(8),RBOPSW   STORE RB PSW IN LOWCORE LOCATION
*
         LD    0,TCBFRS           LOAD THE USER FLOATING REGISTERS
         LD    2,TCBFRS+1*8
         LD    4,TCBFRS+2*8
         LD    6,TCBFRS+3*8
         LM    R0,R15,TCBGRS      LOAD ALL REGISTERS FROM TCBREGS
*
         CLI   LEVELFLG,C'S'      AT THIS POINT, WE SHOULD ALWAYS BE
*                                 AT THE SYSTEM LEVEL
         BNE   LEVELABN           IF WE AREN'T THEN HAVE A LOGIC ERROR
*                                 AND WE SHOULD ABEND WITH A DUMP
         MVI   LEVELFLG,C'T'      OTHERWISE, SET LEVEL FLAG TO 'TASK'
*
         LPSW  LOWPSW             TRANSFER CONTROL TO NEW TASK
*
* THIS IS WHERE WE GO WHEN THERE ARE IS NO REQUEST BLOCK TO BE
* DISPATCHED; WE WILL ABEND WITH A DUMP.
*
NOREQBLK DS    0H
         SR    R2,R2              SEND JOB MESSAGES TO XPRNT
         L     R12,CVTSUB1        GET ADDRESS OF 'JOB END' MSG SUBRTN
         BALR  R14,R12            PRINT THE JOB END INFORMATION
*
* BEFORE DISPATCHING THE NEXT USER JOB, WE MUST REMOVE THE TASK CTL
* BLK FROM THE ACTIVE CHAIN. IF THIS IS THE WAIT OR NIP/MS TCB, THEN
* THERE IS A SERIOUS PROBLEM AND WE SHOULD ABEND WITH A DUMP.
*
         MVC   TCBTWAIT(4),TCBDONE MARK THIS TCB AS COMPLETED
*
         L     R7,TCBTCB          SET REG 7 TO @ OF NEXT TCB IN CHAIN
         L     R8,TCBBACK         SET REG 8 TO @ OF PREVIOUS TCB
*
         LTR   R7,R7              IF THIS IS THE WAIT TCB
         BZ    BADTCB             ABEND WITH A DUMP
         LTR   R8,R8              IF THIS IS THE NIP/MS TCB
         BZ    BADTCB             ABEND WITH A DUMP
*
* FOR SOS-D, WE WILL LEAVE THE TCB ON THE CHAIN, ALTHOUGH IT WILL NOT
* BE DISPATCHABLE.
*
*        LR    R4,R8              ADDRESS PREVIOUS TCB
*        ST    R7,TCBTCB          REMOVE COMPLETED TCB FROM CHAIN
*        LR    R4,R7              ADDRESS NEXT TCB IN CHAIN
*        ST    R8,TCBBACK         REMOVE COMPLETED TCB FROM CHAIN
*
* NOW WE WILL MAKE THE NIP/MS TCB DISPATCHABLE BY POSTING IT VIA SVC 2.
* THIS WILL CAUSE THE NEXT USER PROGRAM TO BE LOADED.
*
         L     R0,DISPPOST        LOAD WAIT/POST BITS & POST CODE
         L     R1,CVTMSECB        GET ADDRESS OF NIP/MS ECB
*
         L     R6,CVTSVCTA        OBTAIN ADDRESS OF THE SVC TABLE
         L     R6,2*8(,R6)        OBTAIN ADDRESS OF SVC 2 MODULE
         BALR  R14,R6             BRANCH TO THE SVC 2 MODULE
*
         L     R3,76              ENSURE ADDRESSABILITY INTO THE CVT
         L     R6,CVT0DS          RE-ESTABLISH ADDRESSABILITY
         B     REDISP             BRANCH BACK TO START OF DISPATCHER
*
* THIS SMALL SUBROUTINE IS USED TO PRINT OUT A MESSAGE LINE. SINCE WE
* ARE AT SYSTEM LEVEL, WE MUST USE A BRANCH ENTRY INTO THE SVC 0 RTN.
* UPON ENTRY, REG 10 SHOULD CONTAIN THE RETURN ADDRESS.
*
DISPPRNT DS    0H
         STM   R0,R15,SVC0SAVE    STORE REG BEFORE BRANCH TO SVC 0
         LA    R1,DISPIOB         POINT TO MESSAGE I/O BLOCK FOR SVC 0
         L     R6,CVTSVCTA        OBTAIN ADDRESS OF THE SVC TABLE
         L     R6,0(,R6)          OBTAIN ADDRESS OF SVC 0 MODULE
*
         XOPC  4                  TURN OF TRACE TEMPORARILY
         BALR  R14,R6             BRANCH TO THE SVC 0 MODULE
         XOPC  2                  TURN TRACE BACK ON WITH PREV. PARMS
*
         L     R3,76              ENSURE ADDRESSABILITY INTO THE CVT
         L     R6,CVT0DS          RE-ESTABLISH ADDRESSABILITY
         LTR   R15,R15            WAS THE I/O SUCCESSFUL?
         BNZ   IOBERROR           IF NOT THEN ABEND WITH A DUMP
         LM    R0,R15,SVC0SAVE    RESTORE REGS BEFORE SVC 0
         BR    R10                RETURN TO THE MAIN PROGRAM BODY
SVC0SAVE DC    16F'-1'            REG VALUES BEFORE BRANCH TO SVC 0
*
* THIS IS WHERE WE GO WHEN THERE ARE NO DISPATCHABLE TCBS IN THE CHAIN.
*
NOTCBS   DS    0H
*
         MVC   DISPMSG(80),DISPMSG2
         BAL   R10,DISPPRNT       PRINT THE FIRST PART OF THE MESSAGE
         MVC   DISPMSG(80),DISPMSG3
         BAL   R10,DISPPRNT       PRINT THE SECOND PART OF THE MESSAGE
         XOPC  25                 ABEND WITH A DUMP
*
* THIS IS WHERE WE GO WHEN THE TCBRB @ IN THE TCB DOES NOT MATCH THE
* REQUEST BLOCK ADDRESS UPON ENTRY IN REGISTER 5.
*
RBINVAL  DS    0H
*
         XOPC  25                 ABEND WITH A DUMP
         DC    C'RB @ IN TCBRB DOES NOT MATCH'
*
* THIS IS WHERE WE GO IF THE NIP/MS OR WAIT TCB WOULD HAVE BEEN
* DELETED ERRONEOUSLY.
*
BADTCB   DS    0H
         XOPC  25
         DC    C'TRIED TO REMOVE NIP/MS OR WAIT TCB'
*
* THIS IS WHERE WE GO WHEN A BAD IOB WAS PASSED TO THE SVC 0 MODULE.
* SUCH AN OCCURRENCE COULD INDICATE A LOGIC ERROR.
*
IOBERROR DS    0H
         XOPC  25
         DC    C'INVALID IOB IN SVC 0 CALL'
*
TCBDONE  DC    CL4'NOTC'          INDENTIFIER OF A USED TCB
DISPPOST DS    0F
         DC    X'7F',C'DSP'       WAIT BIT/POST BIT/POST CODE
ZEROTIME DC    XL4'00000000'      NULL VALUE OF A TCB TIME FIELD
*
DISPIOB  DS    0F
         DC    CL4'IOB '          I/O BLOCK IDENTIFIER
         DC    X'0000'            PRINT TO DEVICE AT X'000F'
         DC    X'01AA'            MESSAGE PRINT REQUEST
         DC    A(DISPMSG)         ADDRESS OF MESSAGE TO BE PRINTED
         DC    H'80'              LENGTH OF EACH MESSAGE IS 60 BYTES
DISPMSG  DC    CL80' '            MESSAGE OUTPUT LINE
*
DISPMSG2 DC CL80' *** DISPATCHER: THERE ARE NO DISPATCHABLE TCBS'
DISPMSG3 DC CL80'                 >>> SOS IS TERMINATING <<<'
*
         ORG   FIRST4K+((*-FIRST4K+31)/32*32)
         DC    CL32'REGS ON ENTRY TO DISPATCHER'
DISPSAVE DC    16F'0'             REGISTER SAVE AREA USED FOR DEBUGGING
         DROP  R3,R4,R5,R6
         EJECT
*
*                  >      IIIII PPPPP L         <
*                   >       I   P   P L        <
*                    >      I   PPPPP L       <
*                   >       I   P     L        <
*                  >      IIIII P     LLLLL     <
*
*
* THE FOLLOWING SECTION OF CODE COMPRISES THE IPL PROGRAM. IT RECEIVES
* CONTROL IMMEDIATELY FOLLOWING A SUCCESSFUL ASSEMBLY BY THE SIMULATED
* IPL PROCESS OF LOADING A PSW FROM LOCATION 0 (WHICH WAS HARDCODED TO
* POINT TO THIS ROUTINE).
*
* REGISTER USAGE:
*
*    R0 = WORK REGISTER 1
*    R1 = WORK REGISTER 2
*    R2 = WORK REGISTER 3
*    R3 = POINTER TO CVT
*    R4 = POINTER TO TCB USED IN DISPATCHING NIP
*    R5 = POINTER TO RB USED IN DISPATCHING NIP
*    R6 = POINTER TO DISPATCHER FOR EXECUTION OF NIP
*    R7 = HOLDS STORAGE KEY FOR EACH 2K SECTION OF MEMORY
*    R8 = ADDRESS OF EACH 2K SECTION OF MEMORY
*    R9 = POINTER TO TCB WORDS
*    R10 = POINTER TO CONTROL BLOCKS (USED IN GETCB100 & FRECB100)
*    R11 = WORK REGISTER 4 (USED IN GETCB100 & FRECB100 MACROS)
*    R12 = BASE REGISTER FOR IPL PGM
*    R13 = USED FOR ADDRESS/VALUE COMPARISIONS
*    R14 = USED FOR ADDRESS/VALUE COMPARISIONS
*    R15 = USAGE NOT DEFINED
*
         ORG   FIRST4K+X'13000'
IPLPGM   DS    0D
*
         BALR  R12,R0             ESTABLISH A BASE REGISTER
         BCTR  R12,R0             ADJUST FOR LENGTH OF BALR INSTRUCTION
         BCTR  R12,R0
         USING IPLPGM,R12         ESTABLISH ADDRESSABILITY INTO IPL PGM
*
         MVC   X'50'(4,R0),TIMERVAL  SET A NEW TIMER VALUE
*
         L     R3,X'4C'           ESTABLISH A POINTER TO THE CVT
         USING CVT,R3             OVERLAY CVT DSECT
*
* ACTIVATE ASSISTV'S TRACING FACILITY TO AID IN DEBUGGING.
*
         LM    R0,R2,R0R1R2       LOAD THE ASSIST TRACE PARAMATERS
         XOPC  3                  INITIATE ASSIST'S TRACING FACILITY
*
* SET SOME LOW-LEVEL SYSTEM FLAGS.
*
         MVI   LEVELFLG,C'S'      SET LEVEL FLAG TO SYSTEM
         MVI   TYP1FLAG,C'0'      SET SVC TYPE FLAG TO NON-LEVEL ONE
*
*
* HERE WE WILL SET ALL OF THE 4K AREAS OF MEMORY USED BY
* THE SYSTEM TO KEY 0 WITHOUT FETCH PROTECTION, AND THE USER 4K
* TO KEY(S) (A,B,C,D) WITH FETCH PROTECTION.
*
* FIRST, WE WILL SET ALL OF MEMORY TO PROTECTION KEY 0 WITHOUT FETCH
* PROTECTION. TO DO THIS, WE WILL ENTER AN ENDLESS LOOP WHICH SETS
* THE PROTECTION KEY AND INCREMENTS TO THE NEXT 2K BLOCK, BEFORE GOING
* BACK TO THE TOP OF THE LOOP. THIS WILL EVENTUALLY CAUSE AN ADDRESSING
* EXCEPTION. SO, WE WILL CHANGE THE ADDRESS OF THE PGM INTERRUPT FLIH
* TO POINT TO A LOOP EXIT LOCATION, WHICH WILL THEN TERMINATE THE LOOP
* WHEN THE PROGRAM INTERRUPT OCCURS. THEN WE WILL RESET THE PROGRAM
* INTERRUPT FLIH TO THE ORIGINAL LOCATION AND CONTINUE.
*
* NOTE THAT THIS ALGORITHM WILL ALLOW US TO DETERMINE THE ACTUAL
* AMOUNT OF MEMORY AVAILABLE TO OUR MACHINE, SINCE THE LOOP WILL STOP
* WHEN WE HIT AN INVALID ADDRESS. THE SIZE OF THE MACHINE'S MEMORY
* CAN THEN BE STORED INTO THE CVT AREA LABELED 'CVTMZ00'.
*
         MVC   PROGCHK(3),NEWTYPE3+5 SAVE OLD S0C5 FLIH ADDRESS
         LA    R2,AFTERLOP        LOAD ADDRESS OF LOOP EXIT POINT
         STCM  R2,7,NEWTYPE3+5    REPLACE PGM INT. FLIH ADDRESS
*
         XR    R7,R7              STORAGE PROTECTION KEY OF 0
         XR    R8,R8              START IN 1ST 2K BLOCK OF REAL MEMORY
SSKLOOP  DS    0H
         SSK   R7,R8              SET THE STORAGE KEY FOR THE 2K BLOCK
POINTHER LA    R8,2048(,R8)       POINT TO THE NEXT 2K BLOCK
         B     SSKLOOP            BRANCH "ENDLESSLY" TO TOP OF LOOP
*
* NOW WE MUST TEST TO ENSURE THAT IT WAS A S0C5 THAT ENDED OUR LOOP,
* AND THAT IT WAS THE SSK INSTRUCTION THAT ABENDED. IT EITHER
* CONDITION IS FALSE THEN WE WILL ABEND WITH A DUMP.
*
AFTERLOP DS    0H
         MVC   NEWTYPE3+5(3),PROGCHK   REPLACE ORIGINAL FLIH ADDRESS
*
* FIRST, WE MUST ENSURE THAT IS WAS A S0C5 THAT CAUSED THE ABEND.
*
         CLI   OLDTYPE3+3,5       TEST FOR A S0C 5
         BNE   ADDRBAD            IF IT WASN'T AN ADDRESSING
*                                 EXCEPTION THEN WE HAVE A LOGIC
*                                 ERROR; WE WILL ABEND WITH A DUMP
*
* NOW WE MUST TEST TO ENSURE THAT IT WAS THE SSK INSTRUCTION THAT
* CAUSED THE ABEND.
*
         LA    R13,POINTHER            LOAD @ OF INSTRUCTION AFTER SSK
         CLM   R13,7,OLDTYPE3+5        TEST IF S0C5 WAS ON SSK INSTR.
         BNE   ADDRBAD                 IF NOT, ABEND WITH A DUMP
*                                      CAUSED BY THE SSK INSTRUCTION
*                                      THEN WE WILL CONTINUE PROCESSING
*
* NOW WE WILL STORE THE HIGHEST AVAILABLE MACHINE BYTE IN MEMORY. THIS
* IS DETERMINED BY DECREMENTING THE ADDRESS REGISTER OF THE FAILING
* SSK INSTRUCTION BY ONE. THIS VALUE WILL BE STORED IN THE CVT FIELD
* NAMED 'CVTMZ00'.
*
         BCTR  R8,R0              DECREMENT ADDRESS REGISTER BY ONE
         ST    R8,CVTMZ00         STORE VALUE IN THE CVT
*
* FINALLY, WE WILL SET THE 2K BLOCK STARTING AT X'800' TO PROTECTION
* KEY 0 ==> WITH <== FETCH PROTECTION.
*
         LA    R8,X'800'          SET STORAGE PROTECTION 2K AT X'800'
         LA    R7,X'08'           GET THE PROTECTION KEY VALUE
         SSK   R7,R8              SET THE STORAGE KEY FOR THAT AREA
*
* NOW WE CAN PRINT A MESSAGE TO INDICATE THAT PROGRAM MEMORY
* PROTECTION HAS BEEN SET AND THAT CVTMZ00 HAS BEEN ESTABLISHED
* AND STORED.
*
         XPRNT IPLMSG1,40
         XPRNT IPLMSG2,60
*
* NOW WE WILL BEGIN TO ESTABLISH CONTROL BLOCK VALUES, IN PREPARATION
* FOR DISPATCHING THE NUCLEUS INITIALIZATION PROGRAM.
*
* WE CAN CONTINUE BY CHAINING TOGETHER OUR CONTROL BLOCKS, A STACK
* WHOSE HEADER IS POINTED TO BY THE CVT FIELD NAMED 'CVTC100H'. THESE
* CONTROL BLOCKS WILL BE USED AS TCBS, RBS, SVRBS, ETC..
*
         L     R10,ADCBPOOL       GET @ OF 1ST CB POOL NODE
         LA    0,CB100#           SET LOOP FOR # OF NODES IN STACK
CBATIPL  FRECB100
         LA    R10,CB100LTH(,R10) POINT TO NEXT NODE TO BE INSERTED
         BCT   0,CBATIPL          INSERT THE NEXT NODE IF ANY ARE LEFT
*
* NOW WE WILL OBTAIN A TCB AND RB (AND INITIALIZE THEM) AND CHAIN THE
* RB FOR THE TCB UNDER WHICH NIP (AND LATER THE USER PROGRAM) WILL
* RUN.
*
         L     R9,CVTTCBP         GET @ OF TCB WORDS
         USING IEATCBP,R9         ESTAB. ADDRESSIBILITY INTO TCB WORDS
*
* OBTAIN A NEW TCB AND RB FROM THE CONTROL BLOCK POOL.
*
         GETCB100 CBREG=R4
         USING TCB,R4             ESTAB. ADDRESSIBILITY INTO TCB DSECT
         XC    TCB(TCBLNTH),TCB   SET ENTIRE TCB TO HEX ZEROS
*
         GETCB100 CBREG=R5
         USING RB,R5              ESTAB. ADDRESSIBILITY INTO RB DSECT
         XC    RB(RBLNTH),RB      SET ENTIRE RB TO HEX ZEROS
*
* NOW WE CAN INITIALIZE OUR TASK CONTROL BLOCK AND OUR REQUEST BLOCK.
* THIS TCB AND RB WILL BE USED TO RUN NIP/MS, AND WILL BE CHAINED
* AS THE FIRST TASK TO BE DISPATCHED.
*
         LR    R0,R4              SAVE ADDRESS OF THIS TCB FOR CHAINING
         ST    R4,CVTHEAD         STORE @ OF FIRST TCB IN CHAIN IN CVT
*
         ST    R5,TCBRB           STORE @ OF TCB REQ. BLK
*
         ST    R4,RBLINK          THIS IS THE ONLY RB FOR NOW
         OI    RBFLGS3,X'80'      SET HIGH BIT OF RBLINK FIELD
*
         MVC   RBTYPE(4),RBIDSTR    SET REQUEST BLOCK TYPE CODE = 'PRB'
         MVC   TCBIDENT(4),TCBIDSTR SET TCB IDENTIFIER STRING
         ST    R4,RBTCB           STORE @ OF TCB FOR THIS TASK
         MVC   RBOPSW(8),NIPPSW   ESTABLISH A RESUME PSW FOR THIS RB
*
         MVI   TCBDSP,X'FF'       SET NIP/MS DISPATCH PRIORITY
         MVI   TCBLMP,X'FF'       SET NIP/MS PRIORITY LIMIT
*
         MVC   TCBNAME(8),NIPTCBNM SET TCB TASK NAME OF NIP
*
* WE MUST ALSO INITIALIZE A TCB AND RB FOR 'WAIT'. THIS TCB WILL BE
* CHAINED JUST AFTER THE NIP TCB, CAUSING NIP TO BE DISPATCHED FIRST.
*
         GETCB100 CBREG=R6
         GETCB100 CBREG=R5
*
* NOW WE CAN INITIALIZE OUR TASK CONTROL BLOCK AND OUR REQUEST BLOCK.
*
         ST    R6,TCBTCB          CHAIN WAIT TCB JUST AFTER NIP TCB
         LR    R4,R6              SET ADDRESSABILITY TO WAIT TCB
*
         XC    TCB(TCBLNTH),TCB   SET ENTIRE TCB TO HEX ZEROS
         XC    RB(RBLNTH),RB      SET ENTIRE RB TO HEX ZEROS
*
         ST    R0,TCBBACK         SET BACKWARD CHAIN TO NIP TCB
*
         ST    R5,TCBRB           STORE @ OF TCB REQ. BLK
         ST    R4,RBLINK          THIS IS THE ONLY RB FOR NOW
         OI    RBFLGS3,X'80'      SET HIGH BIT OF RBLINK FIELD
*
         MVC   RBTYPE(4),RBIDSTR    SET REQUEST BLOCK TYPE CODE = 'PRB'
         MVC   TCBIDENT(4),TCBIDSTR SET TCB IDENTIFIER STRING
         ST    R4,RBTCB           STORE @ OF TCB FOR THIS TASK
         MVC   RBOPSW(8),WAITPSW  ESTABLISH A RESUME PSW FOR THIS RB
*
         MVI   TCBDSP,X'10'       SET WAIT TCB DISPATCH PRIORITY
         MVI   TCBLMP,X'10'       SET WAIT TCB PRIORITY LIMIT
*
         MVC   TCBNAME(8),WTTCBNM SET TCB TASK NAME OF NIP
*
         MVC   LOWTIME(4),X'50'   COPY INITIAL TIMER VALUE FOR NIP/MS
*
* NOW WE CAN BRANCH TO THE DISPATCHER.
*
         L     R6,CVT0DS          LOAD ADDRESS OF CHAP
         BR    R6                 BRANCH TO CHAP
*
* WE WILL COME HERE WHEN WE ABEND WITH OTHER THAN A S0C5 IN OUR MEMORY
* PROTECTION LOOP, OR ABEND ON OTHER THAN THE SSK INSTRUCTION. EITHER
* OF THESE TWO CONDITIONS INDICATES A LOGIC ERROR.
*
ADDRBAD  DS    0H
         XOPC  25                      ABEND WITH A DUMP
         DC    C'UNEXPECTED ABEND IN MEMORY PROTECTION LOOP'
*
* THIS IS THE DATA AREA FOR THE IPL PROGRAM.
*
R0R1R2   DC    F'0'               ASSIST TRACE PARAMATERS
         DC    A(HIGHEST)
         DC    XL4'00E08040'
*
         DS    0F
TIMERVAL DC    X'7FFFFFFF'        INITIAL TIMER VALUE FOR IPL PGM
*
* THE FOLLOWING ITEMS ARE USED IN INITIALIZING OUR CONTROL BLOCK
* POOL AND SETTING UP A TCB AND RB FOR THE EXECUTION OF THE NUCLEUS
* INITIALIZATION PROGRAM.
*
ADCBPOOL DC    A(CB100POL)        ADDRESS OF THE CONTROL BLOCK POOL
NIPTCBNM DC    CL8'TCBMAST '      TCB TASK NAME OF SOS NIP
WTTCBNM  DC    CL8'TCBWAIT '      TCB TASK NAME OF WAIT ROUTINE
RBIDSTR  DC    CL4'PRB '          NIP REQUEST BLK TYPE IS PRB
TCBIDSTR DC    CL4'TCB '          TCB INDENTIFIER STRING
NIPPSW   DC    X'FF0401190F',AL3(NIP) PSW TO DISPATCH NIP
WAITPSW  DC    X'FFF601190F',AL3(AN0119) PSW TO DISPATCH WAIT ROUTINE
AN0119   XOPC 25
*
* THE FOLLOWING VALUES ARE USED IN SETTING THE MEMORY PROTECTION
* KEYS FOR THE VARIOUS AREAS.
*
USERA    DC    A(REGIONA)         ADDRESS OF USER REGION A
*
*
PROGCHK  DC    AL3(0)             OLD PROGRAM CHK FLIH ADDRESS SAVED
*                                 WHILE SETTING STORAGE KEYS
*
* IPL MESSAGES:
*
IPLMSG1  DC CL40' *** IPLPGM: STORAGE KEYS HAVE BEEN SET'
IPLMSG2  DC CL60'             CVTMZ00 HAS BEEN ESTABLISHED AND STORED'
*
         DROP  R3,R4,R5,R9,R12
         EJECT
*
*                  >      CCCCC V   V TTTTT     <
*                   >     C     V   V   T      <
*                    >    C     V   V   T     <
*                   >     C      V V    T      <
*                  >      CCCCC   V     T       <
*
*
* THIS IS WHERE THE CVT IS LOCATED.
*
         ORG   FIRST4K+X'14800'
CVTABLE  DC    XL(CVTLNTH)'00'
*
* SOME OF THE FIELDS IN THE CVT MUST BE HARDCODED. THIS WILL BE
* DONE HERE.
*
         ORG   CVTABLE
         DC    A(TCBWORDS)        POINTER TO TCB WORDS
         DC    A(SVCTABLE)        POINTER TO THE SVC TABLE
         DC    A(0)               POINTER TO FIRST TCB IN CHAIN
         DC    A(UCB000C)         POINTER TO FIRST UCB IN UCB CHAIN
*
         ORG   CVTABLE+X'18'
         DC    A(CB100HDR)        ADDRESS OF CTL BLOCK HEADER NODE
         DC    A(DISPATCH)        ADDRESS OF THE DISPATCHER
         DC    A(BEGINIO)         ADDRESS OF THE BEGIN I/O ROUTINE
         DC    A(CHAP)            ADDRESS OF CHAP ROUTINE
         DC    A(TASKINFO)        ADDRESS OF RTN TO PRINT TASK INFO
*
         ORG   CVTABLE+X'30'
         DC    A(BRABEND)         ADDRESS OF BRANCH-TO-ABEND ROUTINE
         DC    A(TYP1FLAG)        ADDRESS OF SVC TYPE FLAG
         DC    A(RQEENQ)          ADDRESS OF RQE ENQUEUE ROUTINE
*
         ORG   CVTABLE+X'50'
         SVC   3                  CVT EXIT ROUTINE (SVC 3)
         BCR   R15,R14
         DC    CL4'CVT '          CVT INDENTIFIER STRING
         ORG
         EJECT
*
*   >      SSSSS V   V CCCCC    TTTTT   A   BBBB  L     EEEEE     <
*    >     S     V   V C          T    A A  B   B L     E        <
*     >    SSSSS V   V C          T   A   A BBBB  L     EEE     <
*    >         S  V V  C          T   AAAAA B   B L     E        <
*   >      SSSSS   V   CCCCC      T   A   A BBBB  LLLLL EEEEE     <
*
*
* THIS IS WHERE THE SVC TABLE IS LOCATED. THE FORMAT FOR EACH ENTRY
* IN THE SVC TABLE IS AS FOLLOWS:
*
*   DISPLACEMENT LENGTH
*   ============ ======
*     0           4   ADDRESS OF THE SVC ROUTINE OR ZERO IN SOME
*                     CASES IF THE SVC IS NOT SUPPORTED.
*     4           1   FLAGS:
*                     00.. .... TYPE 1 SVC -- NO SVRB
*                     10.. .... TYPE 2 SVC -- SVRB WILL BE USED
*                     11.. .... TYPE 3 OR 4 SVC -- SVRB WILL BE USED
*     5           3   RESERVED
*
* NOTE THAT UNUSED SVC ARE SET TO A DOUBLEWORD OF '0'.
*
MAXSVC#  EQU   15
SVCTABLE DC    A(SVC0RTN),XL1'00',XL3'00'
         DC    A(SVC1RTN),XL1'00',XL3'00'
         DC    A(SVC2RTN),XL1'00',XL3'00'
         DC    A(SVC3RTN),XL1'00',XL3'00'
         DC    D'0'
         DC    D'0'
         DC    D'0'
         DC    D'0'
         DC    A(SVC8RTN),XL1'80',XL3'00'
         DC    D'0'
         DC    D'0'
         DC    D'0'
         DC    D'0'
         DC    D'0'
         DC    A(SVC14RTN),XL1'C0',XL3'00'
         DC    D'0'
         DC    X'1BFF07FE'        END OF SVC TABLE MARKER
*
* THIS MARKS THE END OF THE ASSISTV TRACE ZONE.
*
HIGHEST  DC    C'HIGHEST'         MARKER TO END OF IPL PROGRAM
*
         END
/*
//*
//* X'00C' IS VIRTRDR1 -- OBJECT MODULES AND USER INPUT.
//VIRTRDR1 DD DSN=&&O(D),DISP=(OLD,DELETE),VOL=SER=ACA105,UNIT=PUB
//         DD DSN=T90RPR1.CS468PUB.OBJLIB(OBJMOD7I),DISP=SHR
//         DD DSN=T90RPR1.CS468PUB.OBJLIB(OBJMOD8I),DISP=SHR
//         DD DSN=T90RPR1.CS468PUB.OBJLIB(OBJMOD9I),DISP=SHR
//         DD DSN=T90RPR1.CS468PUB.OBJLIB(OBJMODNI),DISP=SHR
//         DD DSN=SYS1.MACLIB(BSP),DISP=SHR
//         DD DSN=T90RPR1.CS468PUB.OBJLIB(ALLNINES),DISP=SHR
//* X'00D' IS VIRTRDR2 -- OBJECT MODULES AND USER INPUT.
//VIRTRDR2 DD DSN=T90RPR1.CS468PUB.OBJLIB(PARM1111),DISP=SHR
//         DD DSN=T90RPR1.CS468PUB.OBJLIB(PARM2222),DISP=SHR
//         DD DSN=T90RPR1.CS468PUB.OBJLIB(PARM3333),DISP=SHR
//         DD DSN=T90RPR1.CS468PUB.OBJLIB(PARM4444),DISP=SHR
//         DD DSN=SYS1.MACLIB(BCS),DISP=SHR
//         DD DSN=T90RPR1.CS468PUB.OBJLIB(ALLNINES),DISP=SHR
//VIRTPRT1 DD SYSOUT=A,DCB=(BLKSIZE=133,RECFM=FM,BUFNO=1) PRT 000E
//VIRTPRT2 DD SYSOUT=A,DCB=(BLKSIZE=133,RECFM=FM,BUFNO=1) PRT 000F
//*
//FT05F001 DD DUMMY
//
